<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线性表]]></title>
    <url>%2F2018%2F10%2F19%2F%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[线性表（sequence list）是最基本、最简单、也是最常用的一种数据结构。 定义123456789101112131415161718192021222324252627ADT List&#123; 数据对象：D=&#123;$a_i$|ai∈ElemSet,i=1,2,3...n&gt;=0&#125;\\n是表长，为0时为空表 数据关系：R1=&#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,i=1,2,3....n&#125; 常用基本操作： 初始化操作： InitList(&amp;L) 无--构造一个空线性表L 引用型操作： ListEmpty(L) 线性表L已存在--判断L是否为空表 ListLength(L) 线性表L已存在--返回L中数据的个数 GetElem(L,i,&amp;e) 线性表L已存在,0&lt;=i&lt;=ListLength(L)--用e返回第i个元素的值 LocateElem(L,e，compare()) 线性表L已存在,compare()时数据元素判定函数--返回L中第一个与e满足compare()关系的位序，若不存在返回0. 加工型操作： ListInsert(&amp;L,i,e) 线性表L已存在,0&lt;=i&lt;=ListLength(L)+1--在L中第i个位置插入新的元素e,L的长度加1 ListDelte(&amp;L,i,&amp;e) 线性表L已存在,0&lt;=i&lt;=ListLength(L)--删除L中的第i个元素，用e返回其值，L的长度减1. 线性表（顺序结构）的存储结构 12345678910111213#define List_Init_Size 100//线性表存储空间的初始分配量（也就是最多能存多少个的值，实际用时不一定会超过这个值，超过了就要报错或者增加最长值）#define ListIncrement 10 //线性表存储空间的分配增量（其实就是初始有几个值）typedef struct&#123; Element *elem;//存储空间的基地址（相当于数组名） int length; //当前长度 int listSize;//当前分配的存储容量（以sizeof(ElemeType)为单位）（就相当于数组的角标）&#125;SqList;//因此也可以这样定义typedef struct&#123; Element date[100]; int length;&#125; 线性表（链式结构–单向链表）的存储结构 12345typedef struct LNode&#123; ElemType data; struct Lnode *next;&#125;LNode,*LinkList;//LinkList 专门用来设置头节点，LinkList head == LNode *head 习题顺序表应用1：多余元素删除之移位算法Time Limit: 1000 ms Memory Limit: 650 KiB Problem Description 一个长度不超过10000数据的顺序表，可能存在着一些值相同的“多余”数据元素（类型为整型），编写一个程序将“多余”的数据元素从顺序表中删除，使该表由一个“非纯表”（值相同的元素在表中可能有多个）变成一个“纯表”（值相同的元素在表中只保留第一个）。要求： 1、必须先定义线性表的结构与操作函数，在主函数中借助该定义与操作函数调用实现问题功能； 2、本题的目标是熟悉顺序表的移位算法，因此题目必须要用元素的移位实现删除； nput 第一行输入整数n，代表下面有n行输入；之后输入n行，每行先输入整数m，之后输入m个数据，代表对应顺序表的每个元素。 Output 输出有n行，为每个顺序表删除多余元素后的结果 Sample Input 1234545 6 9 6 8 93 5 5 55 9 8 7 6 510 1 2 3 4 5 5 4 2 1 3 Sample Output 12346 9 859 8 7 6 51 2 3 4 5 Hint Source 主要考察数组的删除 （ListDelte），数组删除某个元素，要把其后的元素往前移动一位，要求a[i]=a[i+1] 思路：先固定住a[i]，从a[i+1]到a[length-1]分别与a[i]比较，相同的话，返回其角标，交给删除函数进行删除，然后指针前移一位 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct&#123; int data[10001]; int length;&#125;SqList;void CreateSql(SqList *a,int n);void ShowSql(SqList *a);void DelSql(SqList *a, int i);int SearchSql(SqList *a, int j);int main()&#123; int n, m, i, j, q, f=-1; SqList a; scanf("%d", &amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d", &amp;m); CreateSql(&amp;a,m); for(j=0;j&lt;a.length;j++)&#123; for(q=j+1;q&lt;a.length;q++)&#123; f=SearchSql(&amp;a,j); if(f==-1)&#123; break; &#125; else&#123; DelSql(&amp;a,f); q--;//注意这个q--的用法，删除完不前置q,就会把a[q]位置的元素漏掉 &#125; &#125; &#125; ShowSql(&amp;a); a.length=0; &#125; return 0;&#125;//创建线性表void CreateSql(SqList *a,int n)&#123; int i; for(i=0;i&lt;n;i++)&#123; scanf("%d", &amp;a-&gt;data[i]); &#125; a-&gt;length=n;&#125;//删除第j个元素void DelSql(SqList *a, int i)&#123; int j; for(j=i;j&lt;a-&gt;length-1;j++)&#123; a-&gt;data[j]=a-&gt;data[j+1]; &#125; a-&gt;length--;&#125;//查询J位置后的重复元素int SearchSql(SqList *a, int j)&#123; int i; for(i=j+1;i&lt;a-&gt;length;i++)&#123; if(a-&gt;data[i]==a-&gt;data[j])&#123; return i; &#125; &#125; return -1;&#125;//输出线性表void ShowSql (SqList *a)&#123; int i; for(i=0;i&lt;a-&gt;length;i++)&#123; printf("%d%c", a-&gt;data[i], i==a-&gt;length-1?'\n':' '); &#125;&#125; 值得注意的是，这里在函数里对线性表操作，必须把地址给传进去，单纯的结构体名不是地址，只代表一个变量。 顺序表应用2：多余元素删除之建表算法Time Limit: 3 ms Memory Limit: 600 KiB Problem Description 一个长度不超过10000数据的顺序表，可能存在着一些值相同的“多余”数据元素（类型为整型），编写一个程序将“多余”的数据元素从顺序表中删除，使该表由一个“非纯表”（值相同的元素在表中可能有多个）变成一个“纯表”（值相同的元素在表中只保留第一个）。要求： 1、必须先定义线性表的结构与操作函数，在主函数中借助该定义与操作函数调用实现问题功能； 2、本题的目标是熟悉在顺序表原表空间基础上建新表的算法，要在原顺序表空间的基础上完成完成删除，建表过程不得开辟新的表空间； 3、不得采用原表元素移位删除的方式。 Input 第一行输入整数n，代表下面有n行输入；之后输入n行，每行先输入整数m，之后输入m个数据，代表对应顺序表的每个元素。 Output 输出有n行，为每个顺序表删除多余元素后的结果 Sample Input 1234545 6 9 6 8 93 5 5 55 9 8 7 6 510 1 2 3 4 5 5 4 2 1 3 Sample Output 12346 9 859 8 7 6 51 2 3 4 5 Hint Source 注意到此题限时非常短，而顺序表的删除与增加元素，要移动很多元素，非常的消耗时间，因此应该采用的是非顺序结构域（链表）存储数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Lnode&#123; int data; struct Lnode *next;&#125;Lnode,*LinkList;LinkList InitList(int n);//构造长度为n的线性表void ListDelete(LinkList q,LinkList p);void LocateElem(LinkList head, int k, LinkList p);void ShowLnode(LinkList head);int main()&#123; int n,m; LinkList head, p; scanf("%d", &amp;m); while(m--)&#123; scanf("%d", &amp;n); head=InitList(n); p=head-&gt;next; while(p!=NULL)&#123; LocateElem(head,p-&gt;data,p); p=p-&gt;next;//不要忘了往后移动 &#125; ShowLnode(head); &#125; return 0;&#125;//尾叉法建立链表LinkList InitList(int n)&#123; LinkList head, p, tail; int m; head=(LinkList)malloc(sizeof(Lnode)); head-&gt;next=NULL; tail=head; while(n--)&#123; p=(LinkList)malloc(sizeof(Lnode)); scanf("%d", &amp;m); p-&gt;next=tail-&gt;next; tail-&gt;next=p; tail=p; p-&gt;data=m; &#125; return head;&#125;//遍历链表并删除void LocateElem(LinkList head, int k,LinkList p)&#123; LinkList q,m; m=p; q=p; p=p-&gt;next; while(p!=NULL)&#123; if(p-&gt;data==k)&#123; q-&gt;next=p-&gt;next; free(p); p=q-&gt;next; &#125; else&#123; q=p; p=p-&gt;next; &#125; &#125; p=m; &#125;//展示链表void ShowLnode(LinkList head)&#123; LinkList p; p=head-&gt;next; while(p!=NULL)&#123; if(p-&gt;next==NULL)&#123; printf("%d\n", p-&gt;data); &#125; else&#123; printf("%d ",p-&gt;data); &#125; p=p-&gt;next; &#125;&#125; 这道题我在函数传参数时犯了一个错误，记录在https://misakasister.github.io/2018/10/06/C%E8%AF%AD%E8%A8%80%20%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E7%90%86%E8%A7%A3/ 顺序表应用3：元素位置互换之移位算法Time Limit: 1000 ms Memory Limit: 570 KiB Problem Description 一个长度为len(1&lt;=len&lt;=1000000)的顺序表，数据元素的类型为整型，将该表分成两半，前一半有m个元素，后一半有len-m个元素（1&lt;=m&lt;=len)，借助元素移位的方式，设计一个空间复杂度为O(1)的算法，改变原来的顺序表，把顺序表中原来在前的m个元素放到表的后段，后len-m个元素放到表的前段。注意：先将顺序表元素调整为符合要求的内容后，再做输出，输出过程只能用一个循环语句实现，不能分成两个部分。 Input 第一行输入整数n，代表下面有n行输入；之后输入n行，每行先输入整数len与整数m(分别代表本表的元素总数与前半表的元素个数），之后输入len个整数，代表对应顺序表的每个元素。 Output 输出有n行，为每个顺序表前m个元素与后（len-m）个元素交换后的结果 Sample Input 123210 3 1 2 3 4 5 6 7 8 9 105 3 10 30 20 50 80 Sample Output 124 5 6 7 8 9 10 1 2 350 80 10 30 20 Hint 注意：先将顺序表元素调整为符合要求的内容后，再做输出，输出过程只能在一次循环中完成，不能分成两个部分输出。 思路：空间复杂度O(1)要求不能新开数组，因此把先第一个元素放最后，然后数组前移，把第一个元素覆盖，重复m次,就把m个元素放到最后了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data[10001]; int length;&#125;SqList;SqList list;void createList(int n)&#123; int i; for(i=0;i&lt;n;i++)&#123; scanf("%d", &amp;list.data[i]); &#125; list.length=n;&#125;void tranList(SqList *list,int m)&#123; //保存第一个数，然后让其他元素向前移动一位 //再把第一个数放到末尾，就完成了，执行m次 int i, j; while(m--)&#123; j=list-&gt;data[0]; for(i=0;i&lt;list-&gt;length-1;i++)&#123; list-&gt;data[i]=list-&gt;data[i+1]; &#125; list-&gt;data[list-&gt;length-1]=j; &#125;&#125;void ShowList(SqList *list)&#123; int i; for(i=0;i&lt;list-&gt;length;i++)&#123; printf("%d%c", list-&gt;data[i],i==list-&gt;length-1?'\n':' '); &#125;&#125;int main()&#123; int n, m, p; scanf("%d", &amp;n); while(n--)&#123; scanf("%d", &amp;m); scanf("%d", &amp;p); createList(m); tranList(&amp;list, p); ShowList(&amp;list); &#125; return 0;&#125; 顺序表应用4-2：元素位置互换之逆置算法(数据改进）Time Limit: 80 ms Memory Limit: 600 KiB Problem Description 一个长度为len(1&lt;=len&lt;=1000000)的顺序表，数据元素的类型为整型，将该表分成两半，前一半有m个元素，后一半有len-m个元素（1&lt;=m&lt;=len)，设计一个时间复杂度为O(N)、空间复杂度为O(1)的算法，改变原来的顺序表，把顺序表中原来在前的m个元素放到表的后段，后len-m个元素放到表的前段。注意：交换操作会有多次，每次交换都是在上次交换完成后的顺序表中进行。 Input 第一行输入整数len(1&lt;=len&lt;=1000000)，表示顺序表元素的总数； 第二行输入len个整数，作为表里依次存放的数据元素； 第三行输入整数t(1&lt;=t&lt;=30)，表示之后要完成t次交换，每次均是在上次交换完成后的顺序表基础上实现新的交换； 之后t行，每行输入一个整数m(1&lt;=m&lt;=len)，代表本次交换要以上次交换完成后的顺序表为基础，实现前m个元素与后len-m个元素的交换； Output 输出一共t行，每行依次输出本次交换完成后顺序表里所有元素。 Sample Input 123456101 2 3 4 5 6 7 8 9 -13235 Sample Output 1233 4 5 6 7 8 9 -1 1 26 7 8 9 -1 1 2 3 4 51 2 3 4 5 6 7 8 9 -1 Hint Source 思路：整体逆置的思想，比如样例： 12341 2 3 4 5 6 7 8 9 -1 将前2个移动到最后-1 9 8 7 6 5 4 3 2 1 整体逆置9 -1 8 7 6 5 4 3 2 1 前2个逆置9 -1 1 2 3 4 5 6 7 8 剩下的逆置 因此要定义一个逆置数组的函数res，res具体就是遍历数组的一半，与另外一半进行交换 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct&#123; int data[10000001]; int length;&#125;SqList;SqList list;void createList(int n)&#123; int i; for(i=0;i&lt;n;i++)&#123; scanf("%d", &amp;list.data[i]); &#125; list.length=n;&#125;//逆置数组void res(int l, int r)&#123; int i, j, t; j=r; for(i=l;i&lt;=(l+r)/2;i++)&#123; t=list.data[i]; list.data[i]=list.data[j]; list.data[j]=t; j--; &#125;&#125;void show()&#123; int i; for(i=0;i&lt;list.length;i++)&#123; printf("%d%c", list.data[i], i==list.length-1?'\n':' '); &#125;&#125;int main()&#123; int l, t, m; scanf("%d", &amp;l); createList(l); scanf("%d", &amp;t); while(t--)&#123; scanf("%d", &amp;m); res(0,list.length-1); res(list.length-m,list.length-1); res(0,list.length-m-1); show(); &#125; return 0;&#125; 顺序表应用5：有序顺序表归并Time Limit: 100 ms Memory Limit: 880 KiB Problem Description 已知顺序表A与B是两个有序的顺序表，其中存放的数据元素皆为普通整型，将A与B表归并为C表，要求C表包含了A、B表里所有元素，并且C表仍然保持有序。 Input 输入分为三行：第一行输入m、n（1&lt;=m,n&lt;=10000）的值，即为表A、B的元素个数；第二行输入m个有序的整数，即为表A的每一个元素；第三行输入n个有序的整数，即为表B的每一个元素； Output 输出为一行，即将表A、B合并为表C后，依次输出表C所存放的元素。 Sample Input 1235 31 3 5 6 92 4 10 Sample Output 11 2 3 4 5 6 9 10 Hint Source 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;Lnode, *LinkList;LinkList createLnode(int n)&#123; Lnode *head, *p, *t; head=(LinkList)malloc(sizeof(Lnode)); head-&gt;next=NULL; t=head; while(n--)&#123; p=(LinkList)malloc(sizeof(Lnode)); scanf("%d", &amp;p-&gt;data); p-&gt;next=NULL; t-&gt;next=p; t=p; &#125; return head;&#125;//归并链表 LinkList merge(LinkList l1, LinkList l2)&#123; LinkList p, q, t; p=l1-&gt;next; q=l2-&gt;next; t=l1; free(l2); while(p!=NULL&amp;&amp;q!=NULL)&#123; if(p-&gt;data&lt;q-&gt;data)&#123; t-&gt;next=p; t=p; p=p-&gt;next;//不要忘了往下移动 t-&gt;next=NULL; &#125; else&#123; t-&gt;next=q; t=q; q=q-&gt;next; t-&gt;next=NULL; &#125; &#125; if(p==NULL)&#123; t-&gt;next=q; &#125;else&#123; t-&gt;next=p; &#125; return l1; &#125; void show(LinkList head)&#123; LinkList p; p=head-&gt;next; while(p!=NULL)&#123; printf("%d%c", p-&gt;data, p-&gt;next==NULL?'\n':' '); p=p-&gt;next; &#125; &#125;int main()&#123; int n, m; LinkList h1, h2; scanf("%d %d", &amp;n, &amp;m); h1=createLnode(n); h2=createLnode(m); h1=merge(h1,h2); show(h1); return 0;&#125; 顺序表应用6：有序顺序表查询Time Limit: 1000 ms Memory Limit: 4096 KiB Problem Description 顺序表内按照由小到大的次序存放着n个互不相同的整数，任意输入一个整数，判断该整数在顺序表中是否存在。如果在顺序表中存在该整数，输出其在表中的序号；否则输出“No Found!”。 Input 第一行输入整数n (1 &lt;= n &lt;= 100000)，表示顺序表的元素个数；第二行依次输入n个各不相同的有序非负整数，代表表里的元素；第三行输入整数t (1 &lt;= t &lt;= 100000)，代表要查询的次数；第四行依次输入t个非负整数，代表每次要查询的数值。 保证所有输入的数都在 int 范围内。 Output 输出t行，代表t次查询的结果，如果找到在本行输出该元素在表中的位置，否则本行输出No Found! Sample Input 1234101 22 33 55 63 70 74 79 80 87455 10 2 87 Sample Output 12344No Found!No Found!10 Hint Source 思路：二分查找（不可能考遍历寻找的。。。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct &#123; int data[100001]; int length;&#125;SqList;void initList(SqList *list,int n)&#123; int i; for(i=0;i&lt;n;i++)&#123; scanf("%d", &amp;list-&gt;data[i]); &#125; list-&gt;length=n;&#125;//二分查找int midsearch(SqList *list, int k, int l, int r )&#123; int mid; mid=(l+r)/2; //相等的情况也能查找,所以不要写等于号 if(l&gt;r)&#123; return -1; &#125; else if(k==list-&gt;data[mid])&#123; return mid; &#125; else if(k&lt;list-&gt;data[mid])&#123; return midsearch(list,k,0,mid-1); &#125; else &#123; return midsearch(list,k,mid+1,r); &#125;&#125;int main()&#123; SqList list; int n, t, k, m; scanf("%d", &amp;n); initList(&amp;list,n); scanf("%d", &amp;t); while(t--)&#123; scanf("%d", &amp;k); m=midsearch(&amp;list, k,0,(list.length)-1); if(m!=-1)&#123; printf("%d", m+1); &#125;else&#123; printf("No Found!"); &#125; printf("\n"); &#125; return 0;&#125; 顺序表应用7：最大子段和之分治递归法Time Limit: 10 ms Memory Limit: 400 KiB Problem Description 给定n(1&lt;=n&lt;=50000)个整数（可能为负数）组成的序列a[1],a[2],a[3],…,a[n],求该序列如a[i]+a[i+1]+…+a[j]的子段和的最大值。当所给的整数均为负数时定义子段和为0，依此定义，所求的最优值为： Max{0,a[i]+a[i+1]+…+a[j]},1&lt;=i&lt;=j&lt;=n。 例如，当（a[1],a[2],a[3],a[4],a[5],a[6]）=(-2,11,-4,13,-5,-2)时，最大子段和为20。 注意：本题目要求用分治递归法求解，除了需要输出最大子段和的值之外，还需要输出求得该结果所需的递归调用总次数。 递归调用总次数的获得，可以参考以下求菲波那切数列的代码段中全局变量count的用法： 12345678910111213141516171819#includeint count=0;int main()&#123; int n,m; int fib(int n); scanf("%d",&amp;n); m=fib(n); printf("%d %d\n",m,count); return 0;&#125;int fib(int n)&#123; int s; count++; if((n==1)||(n==0)) return 1; else s=fib(n-1)+fib(n-2); return s;&#125; Input 第一行输入整数n(1&lt;=n&lt;=50000)，表示整数序列中的数据元素个数； 第二行依次输入n个整数，对应顺序表中存放的每个数据元素值。 Output 一行输出两个整数，之间以空格间隔输出： 第一个整数为所求的最大子段和； 第二个整数为用分治递归法求解最大子段和时，递归函数被调用的总次数。 Sample Input 126-2 11 -4 13 -5 -2 Sample Output 120 11 Hint Source 思路： 子段与子序列不一样 子段的定义：(a[i],a[i+1],…+a[j]) 是连续的, 相当于连续的子序列 子序列：一个序列(a1, a2, …, aN)，子序列(ai1, ai2, …, aiK)，这里1&lt;= i1 &lt; i2 &lt; … &lt; iK &lt;= N。不一定是连续的 样例找的是a[2],a[3],a[4] (从1开始数) 三个数的和为20。 网上搜到了一个视频，但需要翻墙才能看。。 分治法的思路就是，将序列分为左右两半，中间点为mid 递归计算左边的最大和lsum和右边的最大和rsum 那么整个序列的最大子段可能在左边lsum（i和j都在左边）,或者右边rsum(i和j都在右边)，或者是i在左边，j在右边，而前两种情况是递归计算出来的，第三种情况需要算一下，左半边的最大值，即从a[mid]开始往左边一直加到a[0](如果是第三种情况，那么a[mid]一定在序列中),用一个lmax记录加的过程中的最大值，同理也要计算右半边的最大值，从a[mid+1]加到a[length-1] ，用rmax记录累加过程中的最大值，那么第三种情况最大和就是lmax+rmax，之后再与lsum，rsum中取一个最大的即可 递归的结束条件就是l==r 只有一个元素的时候，需要注意的是如果为负值要返回0 12345 lmax rmax &lt;-------|-------&gt;&lt;-------------------&gt;|&lt;-------------------&gt; lsum rsuma[0]...........a[mid]|a[mid+1].............a[length-1] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct &#123; int data[50001]; int length;&#125;Sqlist;int count=0;void createSqlist(Sqlist *list,int n);int sub(Sqlist *list, int l, int r);int main()&#123; Sqlist list; int n, k; scanf("%d", &amp;n); createSqlist(&amp;list,n); k=sub(&amp;list,0,(list.length)-1); printf("%d %d\n", k, count); return 0;&#125;void createSqlist(Sqlist *list,int n)&#123; int i; for(i=0;i&lt;n;i++)&#123; scanf("%d", &amp;list-&gt;data[i]); &#125; list-&gt;length=n;&#125;int sub(Sqlist *list, int l, int r)&#123; int sum, lmax, rmax, lsum, rsum, i, mid; count++; if(l==r)&#123; return list-&gt;data[l]&gt;0?list-&gt;data[l]:0; &#125; mid=(l+r)/2; lsum=sub(list,l,mid); rsum=sub(list,mid+1,r); //i和j不在同一个区间 sum=0; lmax=0;//记录左边包含a[mid]的最大和 for(i=mid;i&gt;=l;i--)&#123; sum+=list-&gt;data[i]; if(sum&gt;=lmax)&#123; lmax=sum; &#125; &#125; sum=0; rmax=0;//记录右边包含a[mid+1]的最大和 for(i=mid+1;i&lt;=r;i++)&#123; sum+=list-&gt;data[i]; if(sum&gt;=rmax)&#123; rmax=sum; &#125; &#125; sum=rmax+lmax; if(lsum&gt;sum)&#123; sum=lsum; &#125; //这里不能使用elseif if(rsum&gt;sum)&#123; sum=rsum; &#125; return sum;&#125; 这里还犯了一个很低级的错误，那就是if与else if混用，以前没注意过233333 if...if 都要进行判断 if...else if 第一个判断成功就不判读第二个 https://zhidao.baidu.com/question/541324936.html 顺序表应用8：最大子段和之动态规划法Time Limit: 5 ms Memory Limit: 500 KiB Problem Description 给定n(1&lt;=n&lt;=100000)个整数（可能为负数）组成的序列a[1],a[2],a[3],…,a[n],求该序列如a[i]+a[i+1]+…+a[j]的子段和的最大值。当所给的整数均为负数时定义子段和为0，依此定义，所求的最优值为： Max{0,a[i]+a[i+1]+…+a[j]},1&lt;=i&lt;=j&lt;=n。 例如，当（a[1],a[2],a[3],a[4],a[5],a[6]）=(-2,11,-4,13,-5,-2)时，最大子段和为20。 注意：本题目要求用动态规划法求解，只需要输出最大子段和的值。 Input 第一行输入整数n(1&lt;=n&lt;=100000)，表示整数序列中的数据元素个数； 第二行依次输入n个整数，对应顺序表中存放的每个数据元素值。 Output 输出所求的最大子段和 Sample Input 126-2 11 -4 13 -5 -2 Sample Output 120 Hint Source 思路：动态规划法： 子问题的划分: C[i-1]对应截止到a[i-1] 的最大子段和，那么C[i]的最大子段和就是 如果C[i-1]+a[i]&gt;C[i],（就是C[i-1]&gt;0)，C[i]=C[i-1]+a[i] 如果C[i-1]+a[i]&lt;C[i],(就是C[i-1]&lt;0),C[i]=a[i] 然后我们找到的最大的C[i]就行了（有点像最长上升子序列，但是这是子串，必须连续，子序列不一定连续） 这题开两个数组会超内存，注意到我们只需要C[i]和C[i-1]，因此用两个变量存一下就行了 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct&#123; int data[100001]; int length;&#125;Sqlist; void createSqlist(Sqlist *list,int n);int main()&#123; Sqlist list; int n, before, after, max, i; scanf("%d", &amp;n); createSqlist(&amp;list, n); max=0; before=list.data[0]; for(i=1;i&lt;list.length;i++)&#123; if(before&gt;0)&#123; after=before+list.data[i]; &#125;else&#123; after=list.data[i]; &#125; if(after&gt;max)&#123; max=after; &#125; before=after; &#125; printf("%d\n", max&gt;0?max:0);//小于0的时候输出0 return 0;&#125;void createSqlist(Sqlist *list,int n)&#123; int i; for(i=0;i&lt;n;i++)&#123; scanf("%d", &amp;list-&gt;data[i]); &#125; list-&gt;length=n;&#125; 数据结构实验之链表一：顺序建立链表Time Limit: 1000 ms Memory Limit: 65536 KiB Problem Description 输入N个整数，按照输入的顺序建立单链表存储，并遍历所建立的单链表，输出这些数据。 Input 第一行输入整数的个数N；第二行依次输入每个整数。 Output 输出这组整数。 Sample Input 12812 56 4 6 55 15 33 62 Sample Output 112 56 4 6 55 15 33 62 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;Lnode, *Linklist;Linklist create(int n);void show(Linklist head);int main()&#123; Linklist head; int n; scanf("%d", &amp;n); head=create(n); show(head); return 0;&#125;Linklist create(int n)&#123; Linklist p, head; head=(Linklist)malloc(sizeof(Lnode)); head-&gt;next=NULL; while(n--)&#123; p=(Linklist)malloc(sizeof(Lnode)); scanf("%d", &amp;p-&gt;data); p-&gt;next=head-&gt;next; head-&gt;next=p; &#125; return head;&#125;void show(Linklist head)&#123; Linklist p; p=head-&gt;next; while(p!=NULL)&#123; printf("%d%c", p-&gt;data,p-&gt;next==NULL?'\n':' '); p=p-&gt;next; &#125;&#125; 数据结构实验之链表二：逆序建立链表Time Limit: 1000 ms Memory Limit: 65536 KiB Problem Description 输入整数个数N，再输入N个整数，按照这些整数输入的相反顺序建立单链表，并依次遍历输出单链表的数据。 Input 第一行输入整数N;；第二行依次输入N个整数，逆序建立单链表。 Output 依次输出单链表所存放的数据。 Sample Input 121011 3 5 27 9 12 43 16 84 22 Sample Output 122 84 16 43 12 9 27 5 3 11 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;Lnode, *Linklist;Linklist create(int n);void show(Linklist head);int main()&#123; Linklist head; int n; scanf("%d", &amp;n); head=create(n); show(head); return 0;&#125;Linklist create(int n)&#123; Linklist p, head, t; head=(Linklist)malloc(sizeof(Lnode)); head-&gt;next=NULL; t=head; while(n--)&#123; p=(Linklist)malloc(sizeof(Lnode)); scanf("%d", &amp;p-&gt;data); p-&gt;next=t-&gt;next; t-&gt;next=p; t=p; &#125; return head;&#125;void show(Linklist head)&#123; Linklist p; p=head-&gt;next; while(p!=NULL)&#123; printf("%d%c", p-&gt;data,p-&gt;next==NULL?'\n':' '); p=p-&gt;next; &#125;&#125; 数据结构实验之链表三：链表的逆置Time Limit: 1000 ms Memory Limit: 65536 KiB Problem Description 输入多个整数，以-1作为结束标志，顺序建立一个带头结点的单链表，之后对该单链表的数据进行逆置，并输出逆置后的单链表数据。 Input 输入多个整数，以-1作为结束标志。 Output 输出逆置后的单链表数据。 Sample Input 112 56 4 6 55 15 33 62 -1 Sample Output 162 33 15 55 6 4 56 12 Hint 不得使用数组。 就是逆序建立链表，不过元素不用输入，而是从原来的链表里拿 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;Lnode, *Linklist;Linklist create();void res(Linklist head);void show(Linklist head);int main()&#123; Linklist head; head=create(); res(head); show(head); return 0;&#125;Linklist create()&#123; int n; Linklist head, p, t; head=(Linklist)malloc(sizeof(Lnode)); head-&gt;next=NULL; t=head; while(1)&#123; scanf("%d", &amp;n); if(n==-1)&#123; break; &#125; p=(Linklist)malloc(sizeof(Lnode)); p-&gt;data=n; p-&gt;next=t-&gt;next; t-&gt;next=p; t=p; &#125; return head;&#125;void res(Linklist head)&#123; Linklist p, q; p=head-&gt;next; q=p-&gt;next;//需要一个q防止断了，让p插在头指针后还能在找到原链表 head-&gt;next=NULL; while(p!=NULL)&#123; p-&gt;next=head-&gt;next; head-&gt;next=p; p=q; //注意这个判断条件，不是单纯的反向建立链表 if(q!=NULL)&#123;//后置指针为空的时候，不能在往后了 q=p-&gt;next; //NULL没有next值 &#125; &#125;&#125;void show(Linklist head)&#123; Linklist p; p=head-&gt;next; while(p!=NULL)&#123; printf("%d%c", p-&gt;data,p-&gt;next==NULL?'\n':' '); p=p-&gt;next; &#125;&#125; 数据结构实验之链表四：有序链表的归并Time Limit: 1000 ms Memory Limit: 65536 KiB Problem Description 分别输入两个有序的整数序列（分别包含M和N个数据），建立两个有序的单链表，将这两个有序单链表合并成为一个大的有序单链表，并依次输出合并后的单链表数据。 Input 第一行输入M与N的值；第二行依次输入M个有序的整数；第三行依次输入N个有序的整数。 Output 输出合并后的单链表所包含的M+N个有序的整数。 Sample Input 1236 51 23 26 45 66 9914 21 28 50 100 Sample Output 11 14 21 23 26 28 45 50 66 99 100 Hint 不得使用数组！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;Lnode, *Linklist;Linklist create(int n);void merge(Linklist h1,Linklist h2);void show(Linklist head);int main()&#123; int n, m; Linklist h1, h2; scanf("%d %d", &amp;n, &amp;m); h1=create(n); h2=create(m); merge(h1,h2); show(h1); return 0;&#125;Linklist create(int n)&#123; Linklist head, p, t; head=(Linklist)malloc(sizeof(Lnode)); head-&gt;next=NULL; t=head; while(n--)&#123; p=(Linklist)malloc(sizeof(Lnode)); scanf("%d", &amp;p-&gt;data); p-&gt;next=t-&gt;next; t-&gt;next=p; t=p; &#125; return head;&#125;void merge(Linklist h1,Linklist h2)&#123; Linklist p1, p2, t; p1=h1-&gt;next; p2=h2-&gt;next; t=h1; h1-&gt;next=NULL; free(h2); while(p1!=NULL&amp;&amp;p2!=NULL)&#123; if(p1-&gt;data&gt;p2-&gt;data)&#123; t-&gt;next=p2; t=p2; p2=p2-&gt;next;//记得下移 t-&gt;next=NULL;//记得断开 &#125;else&#123; t-&gt;next=p1; t=p1; p1=p1-&gt;next; t-&gt;next=NULL; &#125; &#125; if(p1==NULL)&#123; t-&gt;next=p2; &#125; if(p2==NULL)&#123; t-&gt;next=p1; &#125;&#125;void show(Linklist head)&#123; Linklist p; p=head-&gt;next; while(p!=NULL)&#123; printf("%d%c", p-&gt;data,p-&gt;next==NULL?'\n':' '); p=p-&gt;next; &#125;&#125; 数据结构实验之链表五：单链表的拆分Time Limit: 1000 ms Memory Limit: 65536 KiB Problem Description 输入N个整数顺序建立一个单链表，将该单链表拆分成两个子链表，第一个子链表存放了所有的偶数，第二个子链表存放了所有的奇数。两个子链表中数据的相对次序与原链表一致。 Input 第一行输入整数N;；第二行依次输入N个整数。 Output 第一行分别输出偶数链表与奇数链表的元素个数；第二行依次输出偶数子链表的所有数据；第三行依次输出奇数子链表的所有数据。 Sample Input 12101 3 22 8 15 999 9 44 6 1001 Sample Output 1234 622 8 44 6 1 3 15 999 9 1001 Hint 不得使用数组！ Source 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;Lnode, *Linklist;Linklist create(int n);void split(Linklist head);void show(Linklist head);int main()&#123; Linklist head; int n; scanf("%d", &amp;n); head=create(n); split(head); return 0;&#125;Linklist create(int n)&#123; Linklist head, p, t; head =(Linklist)malloc(sizeof(Lnode)); head-&gt;next=NULL; t=head; while(n--)&#123; p=(Linklist)malloc(sizeof(Lnode)); scanf("%d", &amp;p-&gt;data); p-&gt;next=t-&gt;next; t-&gt;next=p; t=p; &#125; return head;&#125;void split(Linklist head)&#123; int odd=0, even=0; Linklist h1, h2, r, t1, t2; r=head-&gt;next; h1=(Linklist)malloc(sizeof(Lnode)); h2=(Linklist)malloc(sizeof(Lnode)); h1-&gt;next=NULL; h2-&gt;next=NULL; t1=h1; t2=h2; while(r!=NULL)&#123; if(r-&gt;data%2!=0)&#123; t1-&gt;next=r; t1=r; r=r-&gt;next; t1-&gt;next=NULL; odd++; &#125; else&#123; t2-&gt;next=r; t2=r; r=r-&gt;next; t2-&gt;next=NULL; even++; &#125; &#125; printf("%d %d\n", even, odd); show(h2); show(h1);&#125;void show(Linklist head)&#123; Linklist p; p=head-&gt;next; while(p!=NULL)&#123; printf("%d%c", p-&gt;data, p-&gt;next==NULL?'\n':' '); p=p-&gt;next; &#125;&#125; 数据结构实验之链表六：有序链表的建立Time Limit: 1000 ms Memory Limit: 65536 KiB Problem Description 输入N个无序的整数，建立一个有序链表，链表中的结点按照数值非降序排列，输出该有序链表。 Input 第一行输入整数个数N；第二行输入N个无序的整数。 Output 依次输出有序链表的结点值。 Sample Input 12633 6 22 9 44 5 Sample Output 15 6 9 22 33 44 Hint 不得使用数组！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;Lnode, *Linklist;Linklist create(int n);void s(Linklist head);void show(Linklist head);int main()&#123; Linklist head; int n; scanf("%d", &amp;n); head=create(n); s(head); show(head); return 0;&#125;Linklist create(int n)&#123; Linklist head, t, p; head=(Linklist)malloc(sizeof(Lnode)); head-&gt;next=NULL; t=head; while(n--)&#123; p=(Linklist)malloc(sizeof(Lnode)); scanf("%d", &amp;p-&gt;data); p-&gt;next=t-&gt;next; t-&gt;next=p; t=p; &#125; return head;&#125;//选择排序 找到最小的放第一个void s(Linklist head)&#123; int t; Linklist p, q; p=head-&gt;next; while(p!=NULL)&#123; q=p-&gt;next; while(q!=NULL)&#123; if(p-&gt;data&gt;q-&gt;data)&#123; t=p-&gt;data; p-&gt;data=q-&gt;data; q-&gt;data=t; &#125; q=q-&gt;next; &#125; p=p-&gt;next; &#125;&#125;void show(Linklist head)&#123; Linklist p; p=head-&gt;next; while(p!=NULL)&#123; printf("%d%c", p-&gt;data, p-&gt;next==NULL?'\n':' '); p=p-&gt;next; &#125;&#125; 数据结构实验之链表七：单链表中重复元素的删除Time Limit: 1000 ms Memory Limit: 65536 KiB Problem Description 按照数据输入的相反顺序（逆位序）建立一个单链表，并将单链表中重复的元素删除（值相同的元素只保留最后输入的一个）。 Input 第一行输入元素个数 n (1 &lt;= n &lt;= 15)；第二行输入 n 个整数，保证在 int 范围内。 Output 第一行输出初始链表元素个数；第二行输出按照逆位序所建立的初始链表；第三行输出删除重复元素后的单链表元素个数；第四行输出删除重复元素后的单链表。 Sample Input 121021 30 14 55 32 63 11 30 55 30 Sample Output 12341030 55 30 11 63 32 55 14 30 21730 55 11 63 32 14 21 Hint Source 不得使用数组！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;Lnode, *Linklist;Linklist create(int n);void show(Linklist head);void del(Linklist head, int n);int main()&#123; int n; Linklist head; scanf("%d", &amp;n); head=create(n); printf("%d\n", n); show(head); del(head, n); return 0;&#125;Linklist create(int n)&#123; Linklist head, p; head=(Linklist)malloc(sizeof(Lnode)); head-&gt;next=NULL; while(n--)&#123; p=(Linklist)malloc(sizeof(Lnode)); scanf("%d", &amp;p-&gt;data); p-&gt;next=head-&gt;next; head-&gt;next=p; &#125; return head;&#125;void show(Linklist head)&#123; Linklist p; p=head-&gt;next; while(p!=NULL)&#123; printf("%d%c", p-&gt;data,p-&gt;next==NULL?'\n':' '); p=p-&gt;next; &#125;&#125;void del(Linklist head, int n)&#123; int count=0; Linklist p, q, r; p=head-&gt;next; while(p!=NULL)&#123; r=p; q=r-&gt;next; while(q!=NULL)&#123; if(p-&gt;data==q-&gt;data)&#123; r-&gt;next=q-&gt;next; free(q); q=r-&gt;next; count++; &#125;else&#123; q=q-&gt;next; r=r-&gt;next; &#125; &#125; p=p-&gt;next; &#125; printf("%d\n", n-count); show(head);&#125; 数据结构实验之链表八：Farey序列Time Limit: 10 ms Memory Limit: 600 KiB Problem Description Farey序列是一个这样的序列：其第一级序列定义为（0/1，1/1），这一序列扩展到第二级形成序列（0/1，1/2，1/1），扩展到第三极形成序列（0/1，1/3，1/2，2/3，1/1），扩展到第四级则形成序列（0/1，1/4，1/3，1/2，2/3，3/4，1/1）。以后在每一级n，如果上一级的任何两个相邻分数a/c与b/d满足（c+d）&lt;=n，就将一个新的分数(a+b)/(c+d)插入在两个分数之间。对于给定的n值，依次输出其第n级序列所包含的每一个分数。 Input 输入一个整数n(0&lt;n&lt;=100) Output 依次输出第n级序列所包含的每一个分数，每行输出10个分数，同一行的两个相邻分数间隔一个制表符的距离。 Sample Input 16 Sample Output 120/1 1/6 1/5 1/4 1/3 2/5 1/2 3/5 2/3 3/44/5 5/6 1/1 Hint Source 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; struct node *next; int top, bottom;&#125;Lnode, *Linklist;void show(Linklist head);Linklist create();Linklist farey(Linklist head, int n);void simple(int *bottom, int *top);int main()&#123; Linklist head; int n; scanf("%d", &amp;n); head=create(); if(n==1)&#123; show(head); &#125;else&#123; head=farey(head, n); show(head); &#125; return 0;&#125;Linklist create()&#123;//初始化一级序列 Linklist head, p; head=(Linklist)malloc(sizeof(Lnode)); head-&gt;next=NULL; p=(Linklist)malloc(sizeof(Lnode)); p-&gt;next=head-&gt;next; head-&gt;next=p; p-&gt;top=1; p-&gt;bottom=1; p=(Linklist)malloc(sizeof(Lnode)); p-&gt;next=head-&gt;next; head-&gt;next=p; p-&gt;top=0; p-&gt;bottom=1; return head;&#125;Linklist farey(Linklist head, int n)&#123; Linklist p, q, r; int i; n--;//一的时候处理了 i=1; while(n--)&#123; i++; q=head-&gt;next; p=q-&gt;next; while(p!=NULL)&#123; //如果直接插入的话会影响下一次的操作，两个相邻的就不是原链表的了，有一个是插入的 if(p-&gt;bottom+q-&gt;bottom&lt;=i)&#123; r=(Linklist)malloc(sizeof(Lnode)); r-&gt;top=p-&gt;top+q-&gt;top; r-&gt;bottom=p-&gt;bottom+q-&gt;bottom; //化简 simple(&amp;(r-&gt;bottom), &amp;(r-&gt;top)); q-&gt;next=r; r-&gt;next=p; //处理操作，保证下次操作的时候不把新插入的元素用来判断 q=r-&gt;next; p=q-&gt;next; &#125;else&#123; p=p-&gt;next; q=q-&gt;next; &#125; &#125; &#125; return head;&#125;void show(Linklist head)&#123; Linklist p; int c=1; p=head-&gt;next; while(p!=NULL)&#123; if(c==10||p-&gt;next==NULL)&#123; printf("%d/%d", p-&gt;top, p-&gt;bottom); printf("\n"); c=0; &#125;else&#123; //制表符是/t printf("%d/%d\t", p-&gt;top, p-&gt;bottom); &#125; p=p-&gt;next; c++; &#125;&#125;void simple(int *bottom, int *top)&#123; //分数化简，找出分子，分母的最大公约数，除以它即可 int t,a,b; a=*bottom; b=*top; //辗转相除法 if(a&lt;b)&#123; t=a; a=b; b=t; &#125; //余数t，让第二个数b去b%t（a对应b，b对应t）,直到a*b==0,b就是最大公约数 while(a%b!=0)&#123; t=a%b; a=b; b=t; &#125; *bottom=*bottom/b; *top=*top/b;&#125; 数据结构实验之链表九：双向链表Time Limit: 1000 ms Memory Limit: 65536 KiB Problem Description 学会了单向链表，我们又多了一种解决问题的能力，单链表利用一个指针就能在内存中找到下一个位置，这是一个不会轻易断裂的链。但单链表有一个弱点——不能回指。比如在链表中有两个节点A,B，他们的关系是B是A的后继，A指向了B，便能轻易经A找到B,但从B却不能找到A。一个简单的想法便能轻易解决这个问题——建立双向链表。在双向链表中，A有一个指针指向了节点B，同时，B又有一个指向A的指针。这样不仅能从链表头节点的位置遍历整个链表所有节点，也能从链表尾节点开始遍历所有节点。对于给定的一列数据，按照给定的顺序建立双向链表，按照关键字找到相应节点，输出此节点的前驱节点关键字及后继节点关键字。 Input 第一行两个正整数n（代表节点个数），m（代表要找的关键字的个数）。第二行是n个数（n个数没有重复），利用这n个数建立双向链表。接下来有m个关键字，每个占一行。 Output 对给定的每个关键字，输出此关键字前驱节点关键字和后继节点关键字。如果给定的关键字没有前驱或者后继，则不输出。注意：每个给定关键字的输出占一行。 一行输出的数据之间有一个空格，行首、行末无空格。 Sample Input 1234510 31 2 3 4 5 6 7 8 9 0350 Sample Output 1232 44 69 Hint Source 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next, *pre;&#125;Lnode, *Linklist;Linklist create(int n);void locate(Linklist head, int k);int main(void) &#123; int n, m, k; Linklist head; scanf("%d", &amp;n); scanf("%d", &amp;m); head=create(n); while(m--)&#123; scanf("%d", &amp;k); locate(head,k); &#125; return 0;&#125;Linklist create(int n)&#123; Linklist head, t, p; head=(Linklist)malloc(sizeof(Lnode)); head-&gt;next=NULL; head-&gt;pre=NULL; t=head; while(n--)&#123; p=(Linklist)malloc(sizeof(Lnode)); scanf("%d", &amp;p-&gt;data); p-&gt;next=NULL; t-&gt;next=p; p-&gt;pre=t; t=p; &#125; return head;&#125;void locate(Linklist head, int k)&#123; Linklist p; p=head-&gt;next; while(p!=NULL)&#123; if(p-&gt;data==k)&#123; if(p-&gt;pre!=head)&#123; //注意这条输出语句，而且前置指针除了head为NULL,p-&gt;pre不可能为空 printf("%d%s", p-&gt;pre-&gt;data,p-&gt;next==NULL?"\n":" "); &#125; if(p-&gt;next!=NULL)&#123; printf("%d\n", p-&gt;next-&gt;data); &#125; &#125; p=p-&gt;next; &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言 函数形参理解]]></title>
    <url>%2F2018%2F10%2F06%2FC%E8%AF%AD%E8%A8%80%20%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[C语言中的形参只有传值，传址本质上也是传值，只不过传的是地址，我们可以通过访问地址的方式进行修改原来的值。 比如 123456789void add(int a)&#123; a++;&#125;int main()&#123; int a=5; add(a); printf("%d", a);//a=5而不是6&#125; 而我们可以通过传指针的方式在add中访问main中的a，去修改main中a的值 123456789void add(int *a)&#123; (*a)++;&#125;int main()&#123; int a=5; add(&amp;a); printf("%d", a);//a=6&#125; 上面的例子比较简单，下面这个是最近做题遇到的问题，困扰了我很久。 这个问题大概内容就是在链表把重复元素删除掉，只保留一个 我的思路就是先用一个指针固定一个元素，然后在用一个指针往后遍历，遇见和固定到的一样就删除掉就行了 12345678910111213141516171819202122232425262728293031323334353637383940void LocateElem(LinkList head, int k,LinkList p)&#123; LinkList q,m; m=p; q=p; p=p-&gt;next; while(p!=NULL)&#123; if(p-&gt;data==k)&#123; ListDelete(q,p); &#125; else&#123; q=p; p=p-&gt;next; &#125; &#125; p=m; &#125;void ListDelete(LinkList q,LinkList p)&#123; q-&gt;next=p-&gt;next; free(p); p=q-&gt;next;&#125;int main()&#123; int n,m; LinkList head, p; scanf("%d", &amp;m); while(m--)&#123; scanf("%d", &amp;n); head=InitList(n);//构造长度为n的线性表并返回 p=head-&gt;next; while(p!=NULL)&#123; LocateElem(head,p-&gt;data,p); p=p-&gt;next; &#125; ShowLnode(head);//展示线性表 &#125; return 0;&#125; LocateElem的作用是遍历链表，而ListDelete删除某个节点，看样子并没有问题，我传的是一个指针，应该可以删除吧，但其实这个程序运行不起来，而把LocateElem中的ListDelete(q,p)中替换为 123q-&gt;next=p-&gt;next;free(p);p=q-&gt;next; 就可以了，这是为什么呢？ 其原因就出现在了ListDelete中的p=q-&gt;next; 这个p是ListDelete中的p，并不是LocateElem中的p，虽然说p的指向是一样的（也就是说*p是一样的，试着输出p-&gt;data看一看）但它们两个不是一个变量！ 这就充分的证明了C语言形参只传值，变量要再拷贝一份的 下面这个例子还能加深理解一下。 1234567891011121314151617181920212223242526272829303132333435363738394041typedef struct &#123; int data[100001]; int length;&#125;SqList;//二分查找int midsearch(SqList *list, int k, int l, int r )&#123; int mid; mid=(l+r)/2; if(l&gt;r)&#123; return -1; &#125; else if(k==list-&gt;data[mid])&#123; return mid; &#125; else if(k&lt;list-&gt;data[mid])&#123; return midsearch(list,k,0,mid-1);//不用取地址了，已经是main中list的地址了，如过还取地址，那就成Sqlist**类型了，取了一个Sqlist指针的指针 &#125; else &#123; return midsearch(list,k,mid+1,r); &#125;&#125;int main()&#123; SqList list; int n, t, k, m; scanf("%d", &amp;n); initList(&amp;list,n);//构造线性表 scanf("%d", &amp;t); while(t--)&#123; scanf("%d", &amp;k);//查找值为k的元素，并返回位置 m=midsearch(&amp;list, k,0,(list.length)-1);//在主函数里要取地址 if(m!=-1)&#123; printf("%d", m+1); &#125;else&#123; printf("No Found!"); &#125; printf("\n"); &#125; return 0;&#125; 接下来分析如何解决在链表删除元素的问题 其实也就是把ListDelete中的p地址可以传到LocateElem中，把p,q想成单纯的变量，不要思考它是指针， 12345ListDelete(Linklist *q, Linklist *p)&#123; (*q)-&gt;next=(*p)-&gt;next;//(*p)就是LocateElem中的p了，**p就是main中的p了 free(*p); *p=*(q)-&gt;next;&#125; 调用ListDelete(&amp;q,&amp;p);就可以了， 其实上面LocateElem中还有一个地方需要修改，那就是m，我m的本意是保存p的地址，好在主函数里用，但是LocateElem中的p根本和main中的p没有关系，所以m就没用了。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 应用]]></title>
    <url>%2F2018%2F09%2F30%2FPHP%20%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[表单传值表单传值即浏览器通过表单元素将用户的选择或者输入的数据交给后台服务器 传值的方式GET传值1 from 表单 &lt;form method=&quot;GET&quot; action=&quot;url&quot;&gt; 表单元素&lt;/form&gt; 2 a标签 &lt;a href=&quot;../index.php?data=&quot;php&quot;&gt; 3 location 对象的href 属性 location.href=&quot;&quot; 4 location 对象的assign()方法 location.assign(&quot;...&quot;) 提交要放到html结构的最后面 post 传值1 post表单传值 &lt;form method=&quot;POST&quot;&gt; 表单元素&lt;/form&gt; 2 post与get的区别 get主要用来获取数据，不改变服务器上的资源，get只是用来获取内容 post传输的数据主要用来增加数据，改变服务器上的资源：post会改变服务器上数据内容 3 post必须使用form表单，get可以使用form和url 4 get 传输的数据在url中可见，post不可见，get传值显示 ?数据名=数据值&amp;数据名=数据值 5 get能传2k（浏览器限制,并非本身的属性），post理论上无限制 6get 传递简单的数据（数值/字符串）post传递复杂数据（二进制等）。 接收数据$_GET 接受get方式提交的数据 $_POST 接收post方式提交的数据 $_REQUEST 接收post方式或者get方式提交的数据 这三个方法都是php超全局，没有范围的限制，预定义数组，表单元素的“name”属性的值作为数组的下标，value属性对应的值就是数组元素的值。点击提交后，$_…就会接受表单的值。 因此表单必须要有name值作为角标，value值作为数组值 1234&lt;form action="echo.php" method="GET"&gt; &lt;input type="text" name="text"&gt; &lt;input type="submit" name="sub"&gt; &lt;/form&gt; 1234&lt;?php $a = $_GET; var_dump($a);?&gt; 复选框处理单选框的处理:radio 可以出现多个选项，但是只能选择一个 表单使用name 属性，使用同名即可：只能选择一个 12&lt;input type="radio" name="gender" value="1"&gt;男&lt;input type="radio" name="gender" value="2"&gt;女 php拿到数据后，组织sql直接存到数据表里即可 多选框的处理： 1表单中name 属性使用数组格式:名字[] name值必须加中括号 //一类复选框数据使用一个 1234&lt;input type="checkbox" name="hobby[]" value="1"&gt;足球&lt;input type="checkbox" name="hobby[]" value="2"&gt;蓝球&lt;input type="checkbox" name="hobby[]" value="3"&gt;排球&lt;input type="checkbox" name="hobby[]" value="4"&gt;球 123&lt;?php $a=$_GET[hobby]；//数组a就接受了被选选项的value值 ?&gt; 2后台接收数据之后，是一个数组（数组不能存储到数据库中） 3php 需要使用分隔符讲数组分解为字符串 implode(分割符，数组) 反向操作：expload 可以把字符串变成数组 文件上传处理表单写法 1) method 的提交方式必须为Post 2）enctype 属性 form表单属性，主要是规范表单数据的编码方式。 http://www.w3school.com.cn/tags/att_form_enctype.asp 属性值 值 描述 application/x-www-form-urlencoded 在发送前编码所有字符（默认） multipart/form-data 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。 text/plain 空格转换为 “+” 加号，但不对特殊字符编码。 3）上传表单：file表单 1234&lt;form action="echo.php" method="POSTenctype="multipart/form-data"&gt;&lt;input type="file" value="img" name="loimg"&gt;&lt;input type="submit" value="true" name="t"&gt;&lt;/form&gt; $_FILES预定义变量$_FILES 是专门用来存储用户上传文件的 123456&lt;?php $a = $_POST; $b = $_FILES; var_dump($a); var_dump($b);?&gt; 上图是b数组的内容，可以看到角标name=img对应的元素为一个数组，其数组内容又包含： name: 文件在客户机上的实际名字 （实际用来保存后缀） type:MIME(多功能互联网邮件扩展)类型，用来在计算机中识别文件类型，比如识别到doc就可以用word打开 tmp_name: 文件在服务器端临时存储的地址和名字（等待脚本被加工，不处理则被删除。） error:文件上传的代号，用来告知php文件接受过程中出现了什么错误 size: 文件大小 移动临时文件1）判断是否为上传的文件 is_uploaded_file() 判断文件是否为http post 上传，参数是tmp_name 2）移动文件：move_uploaded_file() 参数1：源文件在哪里（tep_name) 参数2：想要保存的url，url需要有文件的新名字（name) 文件上传后会保存到$_file中，那么访问文件信息的形式就是\$_file[“name值”][“属性值”] 12345&lt;?php $a = $_FILES['loimg']; if (is_uploaded_file($a['tmp_name'])) &#123; move_uploaded_file($a['tmp_name'], '..\\'.$a['name']);\\第一个反斜杠是转义的意思 或者写错../也行 &#125; 多文件上传结构同名表单1234567 &lt;form action="echo.php" method="POST" enctype="multipart/form-data"&gt;&lt;input type="file" name="hobby[]" value="1"&gt;&lt;input type="file" name="hobby[]" value="2"&gt;&lt;input type="file" name="hobby[]" value="3"&gt;&lt;input type="file" name="hobby[]" value="4"&gt;&lt;input type="submit"&gt; &lt;/form&gt; 会将表单名形成一个数组，而且将文件对应的五元素（name, tmp_name等）再形成一个数组，每个文件对应元素下标所对应的文件是一样的，name[0]与tmp_name[0]对应是用一个文件 不同名表单每个文件都会形参一个下标为name的数组 123456&lt;form action="echo.php" method="POST" enctype="multipart/form-data"&gt;&lt;input type="file" name="h1" value="1"&gt;&lt;input type="file" name="h2" value="2"&gt;&lt;input type="file" name="h3" value="3"&gt;&lt;input type="file" name="h4" value="4"&gt;&lt;input type="submit"&gt; 多文件的遍历与读取不同名文件直接$files[name]就可以取出来 如果文件的个数不确定，就要用到foreach去遍历 1234567&lt;?php foreach($FILES as $key)&#123; //$key就是一个完整的上传文件信息 if(is_uploaded_file($key['tmp_name']))&#123; move_uploaded_file($key['tmp_name'],'url'); &#125; &#125; 同名多文件上传：想办法得到一个文件对应的五个元素。从$_FILES中把对应元素取出来，之后存放在一个数组中。 12345678910&lt;?php if(isset($_FILES['form-name']['name'])&amp;&amp;is_array($_FILES['form-name']['name']))&#123; $arr=array(); foreach($FILES['form-name']['name'] as $key =&gt; $value)&#123; $arr[]=array( 'name'=&gt;$value, 'tmp_name'=&gt;$_FILES['form-name']['tmp_name'][$key], ) &#125; &#125; 文件处理当上传一个文件，我们需要判断 文件类型是否合适（mime类型）？文件存储到的位置？文件格式的限制（后缀名）？大小的限制？还需要将文件的路径和文件名字返回。 如果上传失败的时候还要告诉用户的错误原因 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;?php// 文件上传（单文件）/*array $file 需要上传的文件信息，一位五元数组array $allow_type 允许上传的mime类型string $path 存储的路径string &amp;$error 出现错误的原因array $allow_format=array() 允许上传的文件格式int max_size 允许上传的最大值*/function upload_single($file, $allow_type, $path, &amp;$error, $allow_formate, $max_size)&#123; // 判断文件是否有效 if (!is_array($file) || !isset($file['error'])) &#123; //文件无效 $error = '文件无效'; return false; &#125; // 判断文件存储路径是否有效 // is_dir() 函数检查指定的文件是否是一个目录。 if (!is_dir($path)) &#123; $error = '路径错误'; return false; &#125; // 判断文件是否上传过程中出错 // 值为0的时候代表上传成功，而且没有5 switch ($file['error']) &#123; case 1: case 2: $error = '文件超过服务器允许的大小'; return false; case 3: $error = '文件只上传了一部分，检查网络'; return false; case 4: $error = '没有选中文件'; return false; case 6: case 7: $error = '文件保存失败'; return false; &#125; // 文件类型处理 //in_array()判断一个元素是否在数组里存在 if (!in_array($file['type'], $allow_type)) &#123; $error = '当前文件不允许上传'; return false; &#125; // 判断后缀名 // 取出后缀名 // strstr — 查找字符串的首次出现 stringstrip // ltrim从字符串左侧移除字符： $ext = ltrim(strstr($file['name'], '.'), '.'); if (!empty($allow_formate) &amp;&amp; !in_array($ext, $allow_formate)) &#123; $error = '当前文件不允许上传'; return false; &#125; // 判断文件大小 if ($file['size'] &gt; $max_size) &#123; $error = '文件超出大小,最大可传'.$max_size.'字节'; return false; &#125; // 构造文件的名字 $fullname = strstr($file['type'], '/', true).date('Y - m - d'); for ($i = 0; $i &lt; 4; ++$i) &#123; //char(ascii)) $fullname .= chr(mt_rand(65, 90)); &#125; $fullname .= '.'.$ext; // 移动到指定目录 if (!is_uploaded_file($file['tmp_name'])) &#123; $error = '上传失败'; return false; &#125; echo $fullname; if (move_uploaded_file($file['tmp_name'], $path.$fullname)) &#123; return true; &#125; else &#123; $error = '上传失败'; return false; &#125;&#125;$file = $_FILES['h1'];$path = '../';$allow_type = array('image/png');$allow_format = array('png', 'jpg');if (upload_single($file, $allow_type, $path, $error, $allow_format, 200000)) &#123; echo 'yes';&#125; else &#123; echo $error;&#125; MySql 扩展php 针对 MySql 数据库提供的扩展，允许php当作mysql的一个客户端连接服务器进行操作。 连接数据库建立连接： 主机地址，默认自动连接3306 $link=mysqli_connect(&#39;服务器地址&#39;，&#39;用户名&#39;，&#39;密码&#39;) 连接资源默认超全局，任何地方都可以调用 设置连接编码 mysqli_query($link,&#39;set names utf8&#39;) mysqli_set_charset(&#39;字符集&#39;) 确定编码：客户端当前所用脚本界面的字符集 执行SQL指令mysqli_query($link,&#39;sql&#39;) 增：mysqli_query($link,&#39;inset...&#39;) insert into 表名[(字段名列表)] values (对应的字段值) 删：mysqli_query($link,&#39;delete...&#39;) delete from 表名 where 字段属性值=值 改：mysqli_query($link,&#39;update...&#39;) update 表名 set 字段属性值 = 新值 [where 条件] 查：mysqli_query($link,&#39;select...&#39;) select 字段名列表 from 表名 执行语句时如果变量的字符串有引号，一定要进行替换处理，展示的时候也要在换回来 也不一定是查询语句，show和desc都可以，只要是将数据展示的语句就可以 查的返回值有true和false 这并不能说明有没有查到数据（都会返回true)，只有语句写错了会返回false。本身是一个结果集，转化为bool用为true 解析结果集获取结果的行数 mysqli_num_rows(结果集) 可以得到结果集中到底有多少行记录 将一种结果资源（php不能直接使用）,转换成一种php能够解析的数据格式：通过从结果集中（结果集指针：类似与数组指针）按照结果集指针所在位置取出对应的一条记录（一行）,返回一个数组，同时指针下移，直到指针移出结果集。 mysqli_fetch_assoc() 获取关联数组，数组的键是字段，值是记录 mysqli_fetch_row() 获取索引数组，键是数字，值是记录 mysqli_fetch_array() 获取关联数组或索引数组，也就是一个数据取两次，通过字段或者数字作为下标都可以得到数据。可以通过第二个参数MYSQL_ASSOC,MYSQL_NUM,MYSQL_BOTH来调整 所有的fetch语句共用一个数据源指针 一些其它函数 mysqli_num_fields($res) 获取结果集中的字段数 mysqli_field_name($res,0) 获取结果集中指定位置的字段 关闭资源主动释放连接,脚本执行结束也会自动释放 mysql_close(&#39;资源&#39;) http协议概念HTTP协议：即超文本传输协议（Hypertext transfer protocol)。是一种详细规定浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传输协议。 http协议是用于www服务器传输超文本到本地浏览器的传送协议。它可以是浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档的拿一部分，以及哪部分首先显示等。 特点客户/服务器模式 简单快速：只需传送请求方式和路径 灵活：允许传送任意类型的数据对象（mime类型） 无连接：每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接 无状态：对于事务处理没有记忆能力。如果后续处理需要前面的信息必须重传。 分类请求协议：浏览器向服务器发起请求的时候需要遵循的协议。 响应协议：服务器向浏览器发起响应的时候需要遵循的协议。 http请求开发者工具-&gt;network中查看 请求行 形式：请求方式 资源路径 协议版本号 GET/index.php http/1.1 请求头： 各项协议内容：具体的协议内容不会每次都使用全部 host：请求的主机地址（必须） accept: 当前请求能够接受服务器返回的类型（mime) accept-language: 接收内容 user-agent:客户浏览器所在点的信息 请求体 请求数据：只有post请求会有请求体。get请求所有的数据都是跟在url之后，会在请求行中的资源路径上体现。 http响应 响应行 形式：协议版本 状态码 状态消息（独占一行） http/1.1 200 ok 200 ok 成功 403 forbidden 没有权限访问 404 not found 未找到页面 500 server internal error 服务器内部错误 响应头 时间 服务器 内容长度 内容类型 常见http响应设置php针对http协议（响应）进行了底层设计，可以通过函数header来实现修改响应头。 header可以设计http响应，因为http协议特点是：响应行，响应头（空行结尾）响应体。认为通过header设计响应头的时候，不应该有任何内容的输出，所以一旦产生内容输出，系统都会认为响应头结束了，响应体开始了，所以如果先输出内容后设置响应头（header使用），理论设置无效。 在php5以后，增加程序内容缓存内容：允许通过服务器在输出内容的时候，不直接返回浏览器而是先在服务器端使用程序缓存保留，有了该内容后，在程序缓存内会自动调整响应头和响应体（允许响应头在已经输出的内容之后在设置），但是会进行警告。 因此header设置响应体之前不要有任何输出 location 重定向 立即跳转（响应体不用解析） 浏览器在解析服务器响应的时候，先判定响应行，继续响应头，最后响应体，location在响应头中，所以浏览器一旦看见该协议便不再向下解析。 refresh 延迟重定向 定时跳转（响应体会解析） content-type 内容类型 mime类型 通过内容告知（mime)，浏览器正确解析内容 content-disposition 内容类型，mime类型扩展，激活浏览器文件下载对话框，浏览器在解析内容的时候，默认是直接解析的，那么有时候需要浏览器不解析，当作内容下载成文件。 12&lt;?php header('content-disposition:attachment;filename=名字'); php模拟http请求浏览器发送http请求向我们的服务器，而我们可以利用php脚本(curl)在我们的服务器里模拟http请求去访问另外一台服务器(也可以自我访问服务器) 原理： curl是一个开源库，支持很多协议，包含http,ftp等。 前提条件：http协议的客户端、服务器模式，http协议不一定局限于浏览器访问，自己访问自己。 curl 扩展库使用： 建立连接 curl_init() 激活curl 连接功能 设置请求选项 curl_setopt() 设定选项 http://php.net/manual/zh/function.curl-setopt.php 执行请求 curl_exec() 执行选项（与服务器发送请求），得到服务器的返回内容 关闭连接 curl_close() 关闭资源 1234567&lt;?php $ch=curl_init()//建立资源 //链接选项 curl_setopt($ch,CURLOPT_URL.'127.0.0.1/index.php')//连接选项 访问另外一台服务器 curl_setopt($ch,CURLOPT_RETURNTRANSFER,TRUE);//文件流形式返回 $c=curl_exec($ch);//执行 curl_close($ch);//关闭 文件编程文件编程指利用php对文件（文件夹）进行增删改查的操作。 目录操作创建目录结构(文件夹) mkdir(url) 创建成功返回true,失败返回false。 错误忽视符号：@ 如果文件夹已经存在了，mkDir(url) 会报错，但是我们不想要他报错（只需要文件夹存在）那么 @mkDir(url) 就可以了 删除 rmdir(url) 读取 将文件夹（路径）按资源方式打开 1 opendir() 打开资源，返回一个路径资源，包含指定目录下的所有文件（文件夹） 2 readdir() 从资源中读取指针所在位置的文件名字，然后指针下移，知道指针移出资源 关闭资源：closedir() 任何目录都包含. 自己的目录 和 .. 上级目录 读取所有内容： 12345678&lt;?php $arr=array(); $r=opendir(url); while($f=readdir($r))&#123;//类似于数据库的操作，全部拿出来 $arr[]=$f; &#125; var_dump($arr); closedir($r); 其它函数 dirname(url) 得到上一层目录,就是把文件夹名或者文件名在url中去掉 realpath(url) 得到真实路径（目录路径），如果是文件那么得到false is_dir(url) 判断是否为路径 scandir(url) 获取一个指定路径下的所有文件，以数组的形式返回，相当于opendir/readdir/closedir 递归遍历目录指定一个目录，将其下的所有文件和目录，及目录下的所有内容输出。 设计思路： 设计一个能够遍历一层文件的函数 如果遍历到的文件是目录，应该调用当前函数，注意. 和 .. 递归出口：该目录没有任何子文件夹。 1234567891011121314151617181920212223242526&lt;?php $dir = '../'; function my_scandir($dir, $lv = 0) &#123; // 不是路径 if (!is_dir($dir)) &#123; dir($dir.'&lt;br/&gt;'); &#125; // 遍历目录 $file = scandir($dir); foreach ($file as $value) &#123; // 排除'.' 和'.. if ($value == '.' || $value == '..') &#123; continue; &#125; echo $value.'&lt;br&gt;'; for ($i = 0; $i &lt; $lv * 4; ++$i) &#123; echo '&amp;nbsp'; &#125; $file_dir = $dir.'/'.$value; //构造目录，$value是一个文件名字 if (is_dir($file_dir)) &#123; my_scandir($file_dir, ++$lv); //一定要传路径 &#125; &#125; &#125; my_scandir($dir); 文件操作php5 常见文件操作函数 1） file_get_contents(url) 获取指定文件的所有内容， 返回布尔值 2） file_put_contents(url，content) 将指定内容写入指定文件内 返回的结果是字符串长度（字节）如果当前路径下不存在该文件，该函数会自动创建，但是目录不存在不行。 php4 文件操作函数 php4 中是将文件操作用资源的形式处理，不论是读还是写都依赖于资源指针。 1）fopen(url, 打开模式) 打开一个文件资源，限定打开模式 http://www.php.net/manual/zh/function.fopen.php 2）fread($res,长度) 从打开的资源读取一定长度 3）fclose(url) 关闭资源 其它文件操作： 1) is_file() 判断文件，不识别路径 2）filesize() 获取文件大小 3）file_exists() 判断文件，识别路径 4）unlink() 取消文件名字与磁盘地址的链接（删除文件） 5）filemtime() 获取文件最后一次修改时间 6 ）fseek() 设定fopen打开的文件指针位置 文件下载从服务器将文件通过http协议传输到浏览器，浏览器不解析保存成相应的文件。 提供下载方式可以通过a标签， &lt;a href=&quot;互联网绝对路径&quot;&gt;&lt;/a&gt; 但是a标签只能下载无法解析的文件（比如不能下载.html)，而且这样会暴露服务器存储数据的位置 通过php下载 设定响应头： 文件返回类型 image/jpg || application/octet-stream （以流的形式下载文件,这样可以实现任意格式的文件下载。） 文件的计算方式：accept-ranges:bytes 设定下载提示：content-disposition:attachment;filename=’文件名字’ 设定文件大小：accept-length： 会话技术用户打开一个浏览器，访问某个web站点，在这个站点点击多个超链接，访问多个web资源，整个过程称之为一个会话。 http协议的特点是无状态/无连接，当一个浏览器连续多次访问一个服务器时，服务器是无法区分多个操作系统是否来自同一个浏览器(用户)。会话技术就是通过http协议想办法让服务器能够识别来自同一个浏览器的多次请求，从而方便浏览器（用户）在访问同一个网站的多次操作中，能够持续进行而不需要进行额外的身份验证。 分类cookie技术 是在http协议下，服务器或脚本可以维护客户工作站上信息的一种方式。cookie 是由web服务器保存在用户浏览器（客户端）上的小文本文件（http响应头），他可以包含有关用户的信息，无论何时用户链接到服务器,站点都可以访问cookie信息。 session技术 时域：指一个终端用户与交互系统进行通信的时间间隔，通常指从注册进入系统到注销退出系统之间经过的时间，以及如果需要的话，可能还有一定的操作空间，session技术是将数据保存到服务器端,无论用户何时连接到服务器，站点都可以访问session信息。 session技术的实现依赖于cookie技术 区别： – cookie session 安全性 存储浏览器端，安全性低 存储服务器端，安全性高 数据大小 数量大小都有限制（20个/4k） 不限 数据类型 简单数据，数值 字符串 复杂数据 自动序列化 保存位置 浏览器 服务器 cookie服务器将数据通过http响应存储到浏览器上,浏览器可以在以后携带对应的cookie数据访问服务器。\ 1 第一次请求时，php通过setcookie 函数将数据通过http协议响应头传输浏览器 2 浏览器在第一次响应时将cookie数据保存到浏览器 3 浏览器后续请求同一个网站的时候，会自动检测是否存在cookie数据，如果存在将在请求头中将数据携带到服务器。 4 php 执行的时候会自动判断浏览器是否携带cookie，如果携带，就自动保存到$_COOKIE中 5 利用$_COOKIE访问Cookie数据 基本使用创建cookie setcookie(名字，值) 名字为字符串 ，值必须时简单类型字符串或者整数 具体的cookie内容在谷歌浏览器中的设置-&gt;内容设置-&gt;cookie中可以查看 访问cookie值 $_COOKIE 预定义变量 得到的是数组 cookie可以实现跨脚本共享数据 生命周期cookie在浏览器生存时间（浏览器在下次访问服务器的时候是否携带cookie） 默认（不设定）时的生命周期：关闭浏览器（会话结束） 设定一个常规时间戳的周期，通过setcookie的第三个参数确定，setcookie(‘a’,’a’,time()+时间)，一定要加时间戳。 设定为0的周期，第三个参数如果为0的话就是默认设置 删除一个cookie的做法：服务器没有权限没有去操作浏览器上的内容，可以通过设定生命周期让浏览器自动判定cookie是否有效，无效就清除 123&lt;?php setcookie('a1','');//清空内容 setcookie('a2','a2',time());//过期 作用范围默认（不设定）的范围 不同的文件夹层级中，设定的cookie默认是在不同的文件夹下有访问限制。上层文件夹中设定的cookie可以在下层（子文件夹）中访问，而子文件夹中设定的cookie不能在上层文件夹中访问。 设定为/ 告知浏览器当前的cookie的作用范围时网站根目录,setcookie的第四个参数 跨子域 在同一级别域名下，可以有多个子域名 不同的域名（主机）之间不能共享cookie 可以通过setcookie的第五个参数控制–有效域名 在设定域名访问的时候设定上级域名即可：we.com 所有以we.com结尾的域名都可以访问该cookie 数组的使用设置形式setcookie(&#39;c[k1]&#39;,&#39;value&#39;) 读取形式 $_COOKIE[&#39;c&#39;][k1] session php碰到session_start() 时开启session会话，会自动检测sessionID 如果cookie中存在，使用现成的。 如果cookie不存在，创建一个sessionID，并通过响应头以cookie的形式保存到浏览器上。 初始化超全局变量$_SESSION 为一个空数组 php通过sessionID去指定位置（session文件存储的位置）匹配对应的文件 不存在该文件，创建一个sessionID 命名文件 存在该文件，读取文件内容（反序列化），将数据存储到$_SESSION中 脚本执行结束,将$_SESSION中保存所有数据序列化存储到sessionID 对应的文件中 基本使用启用session，任何时候都要开启session（脚本使用到$_SESSION就开启一次） 12345&lt;?php session_start();//开启session //设置sessions数据 $_SESSION['name']='mark'; $_SESSION['hobby']=array("footbal","basktbal"); 可以跨脚本访问，实现数据的共享。（两个脚本都要有session_start()） 删除一个session信息使用unset() 删除全部的数据：$_SESSION=array() 基础配置在php.ini中 session.name 保存到cookie中sessionID对应的名字 session.auto_start 是否自动开启session（无需手动session_start()) session.save_handler session数据的保存方式，默认是文件形式 session.save_path session文件存储到的位置（需要修改，默认系统的临时文件存储） session.cookie_lifetime sessionID对应cookie的生命周期，默认是会话结束 session.cookie_path sessionID在浏览器存储之后允许服务器访问的路径 session.cookie_domain 允许访问的子域 全局配置，直接在php.ini中修改 脚本中配置，ini_set(名称，值) 函数在运行中设定某些配置项（只会对当前运行的脚本有效） 销毁session删除session对应的session文件 session_destroy() 垃圾回收机制给session文件指定生命周期，通过文件最后的修改时间与生命周期进行结合判断，过期了就可以把对应的session文件删除 123任何一次session开启（seesion_start)，session都会尝试读取session文件读取session文夹后，有几率触发垃圾回收机制垃圾回收机制会自动读取所有的seesion文件的最后编辑时间与生命周期进行判断。 垃圾回收的配置 session.gc_maxlifetime= 1440 session文件的最大生命周期是1440秒 session.gc_probability= 1 垃圾回收概率分子 session.gc_divisor=1000 垃圾回收概率分母 禁用cookie后的使用session技术的使用需要利用cookie技术来保存sessionID,从而使php能够得到相同的seesionID,从而访问相同的session文件。 没有cookie，脚本执行到 session_start 就会产生一个新的sessionID 和session文件。 解决方案：session_id 和session_name 来获得sessionID 或者 name 从而解决session_start产生新的sessionID 123456789101112&lt;?php session_start();//开启 //获取sessionID和名字 $id= session_id(); $name=session_name();//默认phpsessid //设置内容 $_SESSION['NAME']='MARK'; //传递给另外一个脚本 echo "&lt;a href = 'tmp.php?&#123;$name&#125;=&#123;$id&#125;'&gt;click&lt;/a&gt;"; 另外一个脚本接受 123456789&lt;?php $name=session_name(); $id=$GET['name']; //设定sessionID session_id($id); //访问 session_start();]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript DOM]]></title>
    <url>%2F2018%2F08%2F24%2FJavaScript%20DOM%2F</url>
    <content type="text"><![CDATA[概念DOM：文档对象模型 DOM–&gt; Document Object Model DOM定义了表示和修改文档所需的方法。DOM对象即为宿主对象，由浏览器厂商定义，用来操作html和xml（没有CSS样式表）功能的一类对象的集合。 获取元素注意：节点与元素节点不一样，节点包含元素节点，注释节点，文本节点等等。 获取元素节点 名称 解释 document.getElementById() 元素id getElementsByTagName() 标签名 返回类数组 实时的选择，包括后面增加的 getElementsByName() 只有部分标签name可生效(表单 表单元素 img iframe) 返回类数组 getElementsByClassName() 类名 ie8(含)以下版本没有 querySelector() CSS选择器 ie7(含) 以下没有 非实时的选择（后面新加的无法选择） querySelectorAll() CSS选择器 ie7(含) 以下没有 非实时的选择（后面新加的无法选择） 基于元素节点的遍历 名称 解释 parentElement 返回当前元素的父节点（ie9（含）以下 不兼容） children 只返回当前元素元素子节点 node.childElementCount ===node.children.length 当前元素节点的子元素个数 ie9（含）以下 不兼容） firstElementChild 返回第一个元素节点 ie9（含）以下 不兼容） lastElementChild 返回的是最后一个元素节点 nextElementSibling/previousElementSlibing 返回后一个/前一个兄弟元素 节点属性通过节点.属性访问 名称 解释 nodeName 元素的标签名，以大写表示，只读 nodeValue Text节点或Comment节点的文本内容，可读写 nodeType 该节点类型 ，只读 attributes Element 节点的属性集合 attributes[0].value可以获得属性值 hasChildNodes() 判断有没有子节点 基本操作增 名称 解释 document.createElement() 创建元素节点 document.createTextNode() 创建文本节点 document.createComment() 创建注释节点 document.createDocumentFragment() 创建文档片段对象 插增加后插入才能在html中显示 名称 解释 parentNode.appendChild() 最后一位插入，相当于push() 把页面已有部分插入，相当于剪贴 parentNode.insertBefore(a,b) a在b之前插入 删 名称 解释 parent.removeChild() 父节点删除子节点 chid.remove() 子节点将自己删除 替换 名称 解释 parent.replaceChild(new,origin) 节点 对属性的修改Element 节点的一些属性 名称 解释 innerHTML 改变html内容 innerText 改变文字内容（老版本火狐不兼容） textContent(IE不好使) Element 节点的一些方法 名称 解释 ele.setAttribute(a，b) a属性名 b属性值 else.getAttribute(a) a属性名 date对象 与 定时器Date 对象Date 对象用于处理日期和时间。 创建 Date 对象的语法： 1var myDate=new Date() 注释：Date 对象会自动把当前日期和时间保存为其初始值。（时间戳） 自定义时间： new Date(year, month, day，hour, minute, second) month从零开始计数 date所用的方法：http://www.w3school.com.cn/jsref/jsref_obj_date.asp 循环定时器setInterval() ：按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数， 两个参数： 函数体 时间（毫秒） 使用时注意事项：与事件绑定时，为了防止重复触发，首先要清除定时器，使用 clearInterval() ，参数为setInterval的返回值（可以用变量接收一下） 延迟定时器当方法执行完成定时器停止(但是定时器还在,只不过没用了); var tmid = window.setTimeout(“方法名或方法”, “延时”); window.clearTimeout(tmid); 获得窗口尺寸获取滚动条滚动距离scrollTop 网页被卷去的高 兼容问题： ie9+ window.pageOffset; 火狐和其它浏览器 doucument.documentElement.scrollTop 谷歌和没有声明 DTD\&lt;DOCTYPE> document.body.scrollTop scrollTo(x,y) 把内容滚动到指定的坐标，一般只使用y值 兼容问题实在是太复杂了，因此封装为一个方法 1234567891011121314151617181920212223/** * 获取滚动的头部距离和左边距离 * scroll().top scroll().left * @returns &#123;*&#125; */function scroll() &#123; if(window.pageYOffset !== null)&#123; return &#123; top: window.pageYOffset, left: window.pageXOffset &#125; &#125;else if(document.compatMode === "CSS1Compat")&#123; // W3C return &#123; top: document.documentElement.scrollTop, left: document.documentElement.scrollLeft &#125; &#125; return &#123; top: document.body.scrollTop, left: document.body.scrollLeft &#125;&#125; 获取可视区域的宽高client clientWidth clientHeight 网页的可见区域宽高 document.body.clientWidth clientLeft clientTop 返回的是元素边框的Boderwidth 如果不指定边框，返回0 获取网页的可视区域 兼容处理 12345678910111213141516171819202122/** * 获取屏幕的宽度和高度 * @returns &#123;*&#125; */function client() &#123; if(window.innerWidth)&#123; // ie9+ 最新的浏览器 return &#123; width: window.innerWidth, height: window.innerHeight &#125; &#125;else if(document.compatMode === "CSS1Compat")&#123; // W3C return &#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125; &#125; return &#123; width: document.body.clientWidth, height: document.body.clientHeight &#125;&#125; onresize当窗口或框架的大小发生改变的时候会被调用 调用：window.onresize=function(){} 结合获得网页的宽高使用 获取自身的宽高和位置offsetWidth和offsetHeight 获取对象自身的宽度和高度，包括内容，边框，内边距 offsetLeft和offsetTop 距离第一个有定位的父级盒子的左边和上边的距离。可以追踪到body 从父元素的内padding开始计算，到子元素的border外 offsetParent 获得当前有定位的父元素 offsetXXX和style.XXX的区别 a) style.left只能获取行内的，而offsetLeft则可以获取到所有的；b) offsetLeft 可以返回没有定位盒子距离左侧的位置；而style.left不可以，其只能返回有定位盒子的left;c) offsetLeft 返回的是数字，而 style.left 返回的是字符串，除了数字外还带有单位：px; 注意：可以用parseInt进行转化；比如：styleLeft=’300px’ —&gt; parseInt(styleLft) —&gt; 300d) offsetLeft是只读的，而style.left是可读写；e) 如果没有给 当前 元素指定过 top 样式，则 style.top 返回的是空字符串。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 对象]]></title>
    <url>%2F2018%2F08%2F21%2FJavaScript%20%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[概念对象是JavaScript的一个基本数据类型，是一种复合值，它将很多值（原始值或者其他对象）聚合在一起，可通过名字访问这些值。即属性的无序集合。 创建方法1 对象字面量/对象直接量 （字面量就是指这个量本身，比如字面量3。也就是指3. 再比如 string类型的字面量”ABC”, 这个”ABC” 通过字来描述。 所以就是字面量，虽然很难下定义。 你就理解成一眼就能知道的量。） 1234567var obj =&#123; name:"xiaoming", age: 12, eat : function()&#123; console.log("food"); &#125;,&#125; 2 构造函数 2.1 自定义构造函数 类似于创建了一个工厂，可以批量生产对象，比如： 123456789101112function Car(color)&#123;//相当于一个工厂模板 this.color = color; this.name="BMW"; this.height = "1400"; this.weight = 1000; this.run = function()&#123; this.health --; &#125;&#125;var car1 = new Car("red");var car2 = new Car("blue"); 构造函数内部原理（有new)//用来区分构造函数与函数 1） 在函数体最前面隐式的加上 this={} 2） 执行 this.xxx=xxx; 3） 隐式的返回this 2.2 系统自带的构造函数 比如 new Object() //不常用 new String() new Number() 等等，相当于系统把“工厂模板写好了” 3 Object.create(原型) 123456Person.prototype.name="xiao";function Person()&#123; &#125;var person=Object.create(Person.prototype) 包装对象js里有原始值和对象。 对象可以随便的增加属性和方法。或删除属性和方法 {用delelte(对象.属性) }。 原始值应该是不能调用属性和方法的，但是js“可以调用”，这就是因为js在后台创建了包装对象。 1234var s="hello";s.index=1;var t=s.index;console.log(t)//undefined 这里给s设置了index属性，但是却无法访问，是因为包装对象在后台创建完成并返回值后会立即销毁。 细节如下： 12345var s="hello";s.index=1;//此时会创建一个new String("hello"),//并增加一个index属性=1，之后销毁var t=s.index;//该对象被销毁了，所以并不能访问console.log(t)//undefined 这就很好的解释了原始值调用属性的问题。比如： 123var str="123456";//创建new String("123456"),得到length返回后，销毁console.log(str.length);//6 原型定义：原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。 12345function Person()&#123;&#125;//在函数"出生时"，Person.prototype(原型)就被定义好了//Person.prototype是个对象，相当于Person生产出的对象的共同祖先var person = new Person(); 利用原型特点和概念，可以提取公用属性。 比如，Person.prototype.LastName=”li” 那么。通过Person()函数构造出的函数都会有这个LastName属性。值为”li”,当然，个体也可以更改LastName的值。 对象查看自己的构造函数 –&gt; constructor（构造器） 1234function Person()&#123;&#125;var person = new Person();person.constructor//functoion Person()&#123;&#125; constructor可以改变。 原型链对象查看原型：__proto__ （隐式属性） __proto__ 属性里面放的是原型 （__proto__ 前后有两个_） 例子： 12345function Person()&#123; //会有一个隐藏属性 //this =&#123;__proto__: Person.prototype&#125;当new时创建。参考上面的构造函数原理 //这里是一个钩子，当this里没有调用的属性是，会去__proto__指向的地址寻找&#125; __proto__ 的值可以修改,也就是说明自己可以更改自己的祖先。 12345678910111213141516function Grand()&#123; this.lastName="xiao";&#125;var grand = new Grand();function Father()&#123;&#125;var father =new Father();father.__proto__=grand;function Son()&#123;&#125;var son= new Son();son.__proto__=father;console.log(son.lastName);//xiao 这就构成了一个原型链，son没有lastName会按着原型链往上寻找，直到找到输出。 区分prototype 和 __proto__prototype是函数属性，代表该构造函数所产生的对象的”爹“，也是函数创建对象的__proto__ 所指 __proto__ 是一个对象的属性，它指向该对象的原型 12JS中每个对象都会有__proto__属性，默认为Object，例如：var a=&#123;&#125;;//这里对象a的__proto__属性就是Object 原型链的终端是Object.prototype, 而Object有toString方法，所以大部分对象都能调用toString()方法。 obj.toString()会输出[Object Object],输出的格式是[object 对象的类型] call/apply call/apply作用的是改变this指向 方法.call(this的指向，参数) 12345678910111213function Person(name, age, sex)&#123; this.name=name; this.age=age; this.sex=sex;&#125;function Student(name, age, sex, tel, grade)&#123; Person.call(this,name,age,sex); this.tel=tel; this.grade=grade;&#125;var student=New Student(...); 这样Student就包含了Person的属性 Person中的this指向了student apply的作用域call一样。 不同的是，call 需要把实参按照形参个数传进去。 apply 需要传一个argument，（就是在参数两边加[]) 继承传统方式： 原型链 过多的继承了没用的方法。 共享原型： 12345678910111213Father.prototyper=&#123; &#125;function Father()&#123; &#125;function Son()&#123;&#125;Son.prototype = Father.prototype 这样Father于Son就公用继承了一个原型。但是想要给Son单独增加原型属性，就会影响Father的属性，所以需要改进。 圣杯模式：找一个中间层 123456789101112131415161718Father.prototyper=&#123; &#125;function Father()&#123; &#125;function Son()&#123;&#125;function F()&#123; &#125;F.prototype = Father.prototypeSon.ptototype=New F() 这样只给F增加属性，不会影响到Father了。 对象枚举for…in 123456789101112var obj =&#123; name:"dfasdf", sex:"male", weight:123, eat: function()&#123; console.log("apple"); &#125;&#125;for(var prop in obj)&#123; console.log(prop);&#125; 会把对象的属性名和方法名赋给prop obj.prop系统内部会转换成obj[“prop”],寻找prop属性 所以用for…in输出对象，要用obj[prop] 属性就是字符串 hasOwnProperty() 可以用来判断是否是自己的属性（是自己的返回真，原型链上的返回假） in ”属性“ in obj 用来判断该属性是否是obj的属性，（包括原型链上的属性） instranceof 用来判断 A对象 是否是B函数构造出来的 A对象 instranceof B函数 看A对象的原型链 有没有B的原型 this函数预编译过程 this –&gt; window 全局作用域里 this–&gt;window call//apply 改变函数运行时this的指向 obj.func(),fun()里面的this指向obj 类数组对于一个普通的对象来说，有相应的length属性，（最好加上push) 那么虽然该对象并不是由Array构造函数所创建的，它依然呈现出数组的行为，在这种情况下，这些对象被称为“类数组对象”。 比如 1234567var obj=&#123; 0:"a", 1:"b", 2:"c", length:3, push:Array.prototype.push&#125; 特点： 可以利用属性名模拟数组的特性 可以动态的增长length属性 如果强行让类数组调用push方法，则会根据length属性值的位置进行属性的扩充。 push的原理： 1234Array.prototype.push=function(target)&#123; obj[obj.length]=target; obj.length++;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 闭包]]></title>
    <url>%2F2018%2F08%2F18%2FJavaScript%20%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[我研究了两天，终于把闭包啃下来了… 函数 声明 表达式首先我们要区分下函数的声明与函数表达式 1234567声明：function test ()&#123;&#125;表达式：var test = function() abc()&#123;&#125; //test.name=abcvar demo = function() &#123;&#125;//匿名函数 demo.name=demo 这两个概念理解清楚会在后面经常出现，注意进行区分，函数声明与函数表达式不一样。 预编译理解JS代码的执行顺序：首先会扫一遍代码有没有语法错误，有错误的话就报错就不执行了，没错误就会进行预编译。 首先说明函数的预编译，然后再说明全局的预编译。说明的顺序与执行的顺序是相反的，两者很相似。 函数 预编译首先需要区分的是变量声明与赋值 var a=100 var a 是声明 a=100 是赋值，注意区分 预编译发生在函数执行的前一刻 分为4步： 12345671 创建AO对象（Activation Object) 也就是作用域 专业名称叫做执行期上下文2 找形参和变量声明，将变量和形参名作为AO属性名，值为undefined3 将实参值和形参值统一4 在函数体里面找函数声明 （函数表达式不行），值赋予函数体 接下来我们举个例子来理解这4步 123456789101112function fn(a) &#123; console.log(a); var a = 123; console.log(a); function a() &#123; &#125; console.log(a); var b = function () &#123; &#125; console.log(b); function d() &#123; &#125; &#125; fn(1); 试问控制台的输出。我们按着预编译的步骤进行分析 在系统刚要执行fn(1)时 1 创建AO对象（Activation Object) 系统内部创建了一个AO对象 123AO&#123; &#125; 2 找形参和变量声明，将变量和形参名作为AO属性名，值为undefined 函数的形参为a 变量声明有 a b, 因此 1234AO&#123; a:undefined, b:undefined&#125; 3 将实参值和形参值统一 1234AO&#123; a:1, b:undefined&#125; 4 在函数体里面找函数声明 （函数表达式不行），值赋予函数体 12345AO&#123; a: function a() &#123; &#125;, b: undefined, d：function d() &#123; &#125;&#125; 到此，预编译过程完毕了。 接下来开始运行fn(1) AO相当于一个仓库，变量的值就从里面拿 所以第一个控制台输出function a() { } 第二个控制台输出时a被赋值为123，因此输出123 第三个同上 第四个b被赋值了一个函数，因此输出函数。 全局 预编译全局预编译与函数预编译的主要不同是全局预编译没有形参，产生GO对象 因此只有三步： 123451 创建GO对象（Global Object) GO对象就是window对象2 找变量声明，将变量和形参名作为GO属性名，值为undefined3 在全局里面找函数声明 ，值赋予函数体 系统的全局预编译要比函数预编译先，可以看下面的例子： 12345678910global =100; function fn()&#123; console.log(global); global = 200; console.log(global); var global = 300; &#125; fn(); var global; 还是说出控制台的输出 1 类似的，系统产生的GO对象为 1234GO&#123; global:undefined, fn:function fn()&#123;&#125;&#125; 2 当fn执行前期有 12345678GO&#123; global:100, fn:function fn()&#123;&#125;&#125;AO&#123; global:undefined&#125; fn开始执行。 因此第一个输出undefined， 第二个输出200. 补充上述操作可以简单的理解为 123函数声明整体提升变量 声明提升 这也是函数体写在函数调用下面可以运行的原因 另外 1 imply global 暗示全局变量：即任何变量，如果变量未经声明就赋值，此变量为全局对象所有。（window） 123456789a=10;--&gt;window.afunction test()&#123; var b=c=123;&#125;//AO识别不了c变量，因为c没有进行声明，直接进行赋值//c被GO识别console.log(c);//window.c-&gt;123console.log(b);//undefined 2 一切声明的全局变量，都是window的属性 1var b=11;--&gt;window.b 作用域链根据我们以前的经验，函数是可以访问外部变量的，这就与作用域有关 123[[scope]]:每个JS函数都是一个对象，对象中有些属性我们可以访问，但是有些不可以，这些属性仅供JS引擎存取，[[scope]]就是其中一个。[[scope]]指的就是我们所说的作用域，其中存取了运行期上下文的集合。作用域链：[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链。 接下来我们进行解释： 前面我们知道了JS文件运行前系统创建GO对象，函数运行前创建AO对象。 产生的对象会放在作用域链的首位。 比如： 123456function a()&#123; function b()&#123; &#125; b();&#125;a(); a执行时，会产生作用域链，如图： 作用域链的第一位是a的AO，第二位是GO 当b函数执行时，会在a的基础上增加自己的AO b作用域链的第一位是自己产生的AO，后两位与a的作用域链一样。（类似于站在巨人的肩膀上那样…) 两个链指向的a AO是同一个，如果b将某一变量值改变，在a里面调用时，变量值也会变。 scope chain 就是作用域链，js执行时会在链的首端找变量，如果AO里没有该变量的话就会依次往后寻找。 当a的函数执行完毕后，会剪断作用域链与a AO的联系。但是a AO里存着b函数，现在，a AO失去了联系，也就是可以说b函数可以说是”消失“了。 下次a函数执行时，会产生一个新的a AO。 观察这个例子，控制台会输出什么。 12345678910 function a()&#123; var num=0; function b()&#123; num++; console.log(num); &#125; b(); &#125;a();a(); 这个很简单，会输出1 1 下面这个呢 1234567891011function a()&#123; var num=0; function b()&#123; num++; console.log(num); &#125; return b;&#125;var t=a();t();t(); 答案是 1 2 其也可以作用域链解释 在var t=a()执行后，a函数已经执行完毕，剪断了a AO，然后t()开始执行。如图 输出1 虽然a函数a AO失去了联系，但是b函数还连着a AO,b执行完毕后，剪断与b AO的联系。这样的话，a的AO与b函数就绑定了。 第二次调用时，会在上图的基础上num=1时加1，因此输出2。 这两个例子的不同就是第二个例子在b函数被销毁前（也就是a函数与a AO剪断关系前）将b函数当作返回值返回到了全局中。 这就涉及到了本篇文章的主角–闭包 闭包当内部函数被保存到外部时，将会生产闭包。闭包会导致原有作用域链不释放，造成内存泄漏。 先说明一下内存泄漏，上面那个例子，本来a函数执行完，应该剪断与a AO的联系，但是b函数却保存下来，如果函数嵌套的比较深，就会造成函数的作用域链很长，被电脑保存起来，这就时内存泄漏（反向理解）。 闭包可以简单理解为内部函数保存了外部函数的劳动。 接下来是最常遇见的闭包情况： 12345678910111213function test()&#123; var arr = []; for(var i = 0;i &lt; 10;i++)&#123; arr[i]=function()&#123; console.log(i); &#125; &#125; return arr;&#125;var t=test();for(var j =0; j&lt; 10;j++)&#123; t[j]();&#125; 控制台会输出10个10,而并不是0，1，2，….9。 需要注意的是，arr[i]=function(){}，赋值时，函数体并不执行。只有当调用时，函数才会执行（函数名后面跟着个小括号），如果改成这样arr[i]=function(){}() 这是函数就会立即执行了，输出的也是0 ，1，2，….9了，当然，返回值数组里放的就不是函数体了。（会报错，但是会输出） 在t=test()时，test()运行完毕，将10个函数存在arr里面 也就是说t[j]执行时，arr[j]里保存的函数作用域链有一个位置保存了test AO，此时test AO里面的i=10。arr[j] AO里没有i变量，因此在test AO里那了 i 值，所以输出了10。（10个arr[j]的作用域共同连着一个test AO） 这不是我们想要的结果，我们想让控制台输出0 1 2 3…9,因此就有解决方案。 立即执行函数一般函数被声明后,会一直等待函数被执行。直到js文件运行完毕，才会被销毁。 立即执行函数，顾名思义，就是该函数被读到时会立即执行，执行完毕后被销毁。 形式为: 12(function ()&#123;&#125;())；W3C 建议（function ()&#123;&#125;)(); 上面闭包的举的粗略解决方案，就用了类似于立即执行函数，在后面添加() (执行符号)，立即执行后，函数名会被销毁。 12var t = function ()&#123;&#125;();console.log(t)；//undefined 只有表达式才能被执行符号执行() 12function a()&#123;&#125;();//不行，这是声明+function a()&#123;&#125;();//可以，这是表达式 知道了立即执行函数可以解决这个问题，因此我们可以把代码改成： 123456789101112131415function test() &#123; var arr = []; for(var i =0; i&lt; 10; i++)&#123; (function(i)&#123; arr[i]=function()&#123; console.log(i); &#125; &#125;(i)) &#125; return arr; &#125; var t = test(); for (var j = 0; j &lt; 10; j++) &#123; t[j](); &#125; 这样控制台就输出0，1， 2，…9了。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css笔记]]></title>
    <url>%2F2018%2F07%2F19%2Fcss%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[CSS是用来干什么的？CSS全名叫Cascading Style Sheets，中文翻译为“层叠样式表”，简称样式表，它是一种制作网页的新技术。HTML文件就只包括资料，而CSS则是告诉浏览器这些资料应该要如何显现出来。打个比方，HTML是房子的框架，而CSS就是室内室外的装潢。css让网页变得好看。 如何在HTML中引入？（1）外联式(推荐) 通过&lt;link&gt;标记来引入外部的CSS文件(.css)。 可以被其它网页共享。 格式：&lt;link href=“CSS的URL” rel=“stylesheet” type=“text/css” /&gt; 注意：&lt;link&gt;标记只能放在&lt;head&gt;中 （2）内嵌式 通过&lt;style&gt;&lt;/style&gt;来书写CSS代码。 只能应用于当前网页，不能被其它网页共享。 注意：&lt;style&gt;标记可以放在网页的任何地方，但一般放在&lt;head&gt;。 （3）行内样式 通过style的属性来书写CSS代码。 每一个HTML元素，都有 style、class、id、name、title 属性。 举例：&lt;p style=“font-size:24px;”&gt;&lt;/p&gt; 关于外联式路径(url)补充： 绝对路径：从是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径。 比如：D:\前端学习\H5+CSS3视频\CSS3 相对路径（推荐）：由这个文件所在的路径引起的跟其它文件（或文件夹）的路径关系。 比如一个目录结构： 1234567文件夹/├── index.html/├── img/│ ├── img1.img/│ ├── img2.img/└── css/ └── main.css/ 你的html文档是index.html，你想要引入main.css,路径为：css/main.css (/相当于进入) 你的CSS文件时main.css，你想要引入一个背景图片img1.img(后面会有专门的内容介绍背景的知识) 路径为：../img/img1.img (.. 相当于上一级) 基础语法CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 1选择器 &#123;声明1; 声明2; 声明3 &#125; 选择器选择器就是选中html中的元素，方便对其的样式进行修改 比较常用的有 类选择器、ID选择器、结构（位置）伪类选择器、并集选择器、后代选择器，子元素选择器 标签选择器标签选择器是指用HTML标签名作为选择器的，按标签名进行分类。 1标签名 ｛样式;&#125; 标签选择器最大的优点是快速为页面中同类型的标签统一样式，但是不能进行差异化设计。 类选择器使用 .类名 表示 1.类名｛样式;｝ 标签调用是通过 class=”类名” 来调用 多类名选择器 我们可以给标签指定多个类名，从而达到给多选择的目的。 1&lt;p class="类名1 类名2"&gt;&lt;/p&gt; 121. 样式的显示效果与HTML中的类名先后顺序无关，受CSS样式的书写上下顺序影响2. 各个类名中间用空格隔开 ID选择器id选择器使用 # 进行标识 ，后面紧跟id名 1#id名｛样式;&#125; 通配符选择器用 * 号进行标识。他是所有选择器中作用范围最广的，能匹配页面中的所有元素 通常用来清除元素边距（不推荐，有专门的Normalize.css可以用来统一跨浏览器样式） 1234*&#123; margin: 0px; padding: 0px;&#125; 伪类选择器伪类选择器通常用于向某些选择器添加特殊效果。 选择器 伪类选择器 链接伪类选择器 :link 未访问的链接 :visited 以访问的链接 : hover 鼠标移动到链接上 : active 选定链接 通常与a标签选择器匹配使用 全部书写的时候顺序不要颠倒。可以单独书写。 结构（位置）伪类选择器（CSS3) :first-child 选取属于器父元素的首个子元素 :last-child 选取其父元素的最后一个子元素 :nth-child(n) 匹配属于其父元素的第N个子元素，n值可以为 even 偶数 odd 奇数 n从0开始开始，因此可以是公式，比如3n选中3的倍数，也可以是确定的数字。 :nth-last-chilf(n) 从最后一个子元素开始记数，匹配第N个元素 选择中的子元素是考虑元素类型的， ”0选取其父元素“相当于选择自己的兄弟元素 目标伪类选择器:target 选择器用于选取当前活动的目标元素 一般与锚点定位结合使用 CSS复合选择器复合选择器是由两个或多个基础选择器，通过不同的组合方式而成的。 交集选择器交集选择器由两个选择器构成，第一个为标签选择器，第二个为类选择器，两个选择器中间不能有空格。 1h1.class&#123;样式;&#125; 并集选择器多个选择器中间用逗号分开（一般换行），所有选择器都会执行后面的样式。 123p,class,id&#123;样式;&#125; 后代选择器后代选择器又称包含选择器，用来选择元素或元素组的后代。 写法：把外层标签写在前面，内层标签写在后面，中间用空格分隔 1class p&#123;样式;&#125; 子元素选择器子元素选择器只能选择某父元素的子元素，其写法就是把父级标签，子级标签写在后面，中间用 &gt; 连接，符号左后各留有一个空格 1.class &gt; p &#123;样式;&#125; 子元素选择器只能选择其亲儿子。不包括孙子等。 属性选择器 选择器 含义 E[xxx] 存在xxx属性 E[xxx=val] 属性值完全等于val E[xxx*=val] 属性值中包含val字符，并可以在任何位置 E[xxx^=val] 属性值中包含val字符，并在开始的位置 E[xxx$=val] 属性值中包含val字符，并在结束的位置 E为选择器 xxx为属性值 可以选中拥有该含义的内容 伪元素选择器之所以被称为伪元素，是因为他们不是真正的页面元素，HTML中没有对应的元素，但是其所有用法和表现行为与真正的页面元素一样，可以对其使用诸如页面元素一样的CSS样式，表面上看上去貌似是页面的某些元素展现，实际上是CSS样式展现的行为，因此被称为伪元素 E为选择器 E::first-letter 文本的第一个单词或字 E::first-line 文本中的第一行（受页面大小的影响） E::selection 改变选中文本时的样式 E::before 与 E::after 必须有content属性 在E元素内部的开始或结束位置创建一个元素，该元素为行内元素。并且不占位置 E:after与E:before 在旧版本里是伪元素，CSS3中”:”用来表示伪类，”::”用来表示伪元素，但是在高版本下E:after与E:before 会被自动识别为E::after 与 E::before 布局盒子模型盒子模型是html+css中最核心的基础知识，理解了这个重要的概念才能更好的排版，进行页面布局。 要把整个页面中的元素理解成一个一个盒子（div） 基础概念CSS盒子模型 又称框模型 (Box Model) ，包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素。如图： 盒子模型顾名思义，你可以将其理解成一个盒子，element的width和height就是物品的大小，padding就是物品距边框的距离，border就是边框的大小，margin就是这个盒子与另外一个盒子的距离 盒子外边距（margin）margin用于设计外边距，设置外边距会在元素之间创建空白。 外边距实现盒子居中可以让一个盒子实现水平居中，需要满足：1必须是块级元素 2盒子必须指定了宽度 然后给盒子左右外边距设置 auto 就可以使盒子居中 margin:0 auto; 注意：行内元素只有左右外边距，没有上下外边距 外边距的合并相邻块元素垂直外边距的合并当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和，而是两者中的较大者。这种现象称为相邻块状元素外边距的合并（也称为外边距塌陷）。 嵌套块元素垂直外边距的合并对两个嵌套关系的块元素，如果父元素没有上内边距级边框，则父元素的上外边距会与子元素的上外边距发生合并，合并后外边距为两者的较大者，即使父元素的上外边距为0，也会发生合并。 解决方案：1 可以为父元素定义1像素的上边框或上内边距， 2 可以为父元素添加overflow:hidden。 盒子边框（border)语法： border：border-width||border-style||border-color 边框样式要先有边框的宽度和颜色 12345none：没有边框样式 （默认值）solid: 边框为单实线dashed: 边框为虚线dotted: 边框为点线double: 边框为双实线 可以单独为盒子的一个边框设置样式 表格的细线边框border-collapse:collapse 合并相邻的边框 圆角边框（CSS3）border-radius: 左上角 右上角 右下角 左下角； 值 描述 测试 length 定义圆角的形状。 测试 % 以百分比定义圆角的形状。 测试 盒子内边距（padding）padding用于设计内边距，指边框与内容之间的距离 值的个数 表达意思 1个值 上下左右的边距 2个值 padding:3px 5px; 上下3像素 左右5像素 3个值 padding:3px 5px 10px;上3像素 左右5像素 下10像素 4个值 padding:上 右 下 左 也可以单独为某一方向设置边距 content宽度和高度使用宽度属性width和高度属性可以对盒子的大小进行控制。 注意： 1 宽度属性width和高度属性height仅使用与块级元素，对行内元素无效（img和input除外） 2 计算盒子总高度时要考虑上下两个盒子的垂直外边距合并的情况 3 如果一个盒子没有给定宽度或者高度或者继承父亲的宽度和高度，则padding不会影响盒子的大小 如果已经给一个盒子指定了宽高，再使用padding会把盒子撑开，定义盒子内容宽高时因考虑这个问题 盒子的大小box-sizing (CSS3)用来修正给盒子增加padding和boder后改变了盒子的大小的问题 content-box 默认值，宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。 也就是说padding和margin会在content外添加。盒子大小=widith+padding+border border-box 为元素设定的宽度和高度决定了元素的边框盒。 就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。 通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 盒子的大小不会超过content规定的宽和高。盒子大小=widith 盒子模型布局的稳定性优先使用 宽度 width 其次 内边距 padding 最后 外边距 margin 原因：1 margin会有外边距合并问题，其次ie6下margin会加倍（bug) 2 padding 会影响盒子的大小，需要进行加减运算 3 width 没有问题，可以使用宽度剩余法或者高度剩余法 宽度剩余法和高度剩余法：利用盒子内容的宽高将其撑开 文档流介绍文档流之前，先介绍元素的三种显示模式 元素的显示模式块级元素(block-level)每个块元素通常都会独自占据一行或多整行，可以对其设置宽度、高度、对齐等属性(依然独自占据一行或多行）。 常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素 块级元素的特点： 1 总是从新行开始 2 高度，行高，外边距、内边距都可以控制 3 宽度默认是容器的100% 4 可以容纳内联元素和其他块级元素 行内元素(inline-level)行内元素（内联元素）不占有独立的区域，仅仅依靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中的文本样式。 常见的行内元素有&lt;a&gt; &lt;stong&gt; &lt;b&gt; &lt;em&gt; &lt;i&gt; &lt;del&gt; &lt;s&gt; &lt;ins&gt; &lt;u&gt; &lt;span&gt;等，其中&lt;span&gt;是最典型的行内元素。 行内元素的特点： 1 和相邻的行内元素在一行上。 2 高宽无效、但水平方向的padding和margin可以设置，垂直方向无效。 3 默认宽度就是它本身的宽度。（不能指定） 4 行内元素之内容纳文本或其它行内元素（a除外） 注意： 1 只用文字才能组成段落，因此p里面不能放块级元素，同理还有标题标签等，他们都是文字类块级标签，里面不能放其它块级元素。 2 链接里面不能放链接 行内块元素(inline-block)在行内元素中有几个特殊的标签——&lt;img&gt; &lt;input&gt; &lt;td&gt; ，可以对它们设置宽高和对齐属性，有些资料称他们为行内块元素。 行内块元素的特点：1 和相邻行内元素（行内块）在一行上，但是之间会有空隙 2 默认宽度是它本身内容的宽度 3 高度、行高、外边距、以及内边距都可以控制 模式的转换 displaydispaly: inline 块转行内 display: block 行内转块 display: inline-block 行、内转换为行内块 概念普通流或者标准流、文档流实际上就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思，比如块级元素会独占一行，行内元素会按顺序依次前后排列；按这种大前提的布局排列之下绝对不会出现例外的情况叫做普通流布局。 定位定位的基本思想很简单，它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。显然，这个功能非常强大，也很让人吃惊。要知道，用户代理对 CSS2 中定位的支持远胜于对其它方面的支持，对此不应感到奇怪。 所以关键的找对相对于谁进行定位。 静态定位（static） position的默认值，默认在文本流的位置。 一般用来清除定位。 相对定位（relative）相对于自身进行定位 1、相对定位时本身不脱离文本流。 2、每次移动是以自己的左上角为基点。 相对定位的的盒子仍在标准流里，它后面的盒子仍以标准流的方式对待它。 绝对定位（absolute）绝对定位是完全脱离标准流的。 绝对定位是以依据最近已经定位（绝对、相对、固定）的父元素（祖先）进行定位的。如果祖先元素没有定位，会以body进行定。 使用技巧:子绝父相，保证父亲占有位置不影响下面的元素，还能保证子元素有定位的对象，以及飘在父元素的上方。 绝对定位实现居中加了absolute的盒子margin：0 auto；会失效。 左右居中： 1、首先left:50%(父盒子宽度的一半) 2、margin-left：自己的宽度一半（负值） 3、transfrom: translate(-50%) 可以不用知道元素的宽度 这个属性在动画里讲 上下居中同理。 固定定位（fixed）固定定位只认浏览器 相对于浏览器（视窗）进行定位 叠加顺序定位元素一定会覆盖没有定位的元素 z-index 1、默认值为0，取值越大，定位元素越居上。 2、只有绝对，相对，固定定位有此属性，其余标准流、浮动、静态定位都无此属性。 定位转换绝对定位、固定定位后会转换为行内块元素。 可以不用转化，直接给宽高。 浮动(float)浮动刚开始的时候是用来做文字环绕图片的。 现在主要用于让多个盒子在同一行显示。 什么是浮动？元素的浮动是指设置了浮动属性的元素会脱离标准流的控制，移动到器父元素指定位置的过程。 选择器{float:属性值;} 属性值 描述 left 向左浮动 right 向右浮动 none 元素不浮动（默认值） 浮动元素的特性浮动是脱离标准流的，不占位置，会影响标准流，浮动只有左右浮动。 浮动首先创建包含块的概念（包裹）。就是说浮动的元素总是找离它最近的父元素对齐。但是不会超过内边距的范围。 浮动的使用方法 给两个黑色的盒子增加浮动，必须要有父盒子（黄色）将其包裹，防止因黑盒子浮动脱离文本流，蓝盒子上移被遮挡。 浮动首先需要添加标准流父级 元素添加浮动后，元素会具有行内块元素的特性，元素的大小完全取决于定义的大小或者默认内容 清除浮动原因由于浮动元素不再占用原文档流的位置，会对后面的元素排版产生影响，所以我们要清除浮动后产生的影响。 清楚浮动本质主要是为了父级元素因为子集浮动引起内部高度为0的问题。 如果父元素没有设置高度，会由子元素撑起来，但当子元素浮动后，脱离了文本流，就会引起父元素的高度为0的问题 解决方法再CSS中，clear属性用于清除浮动，其基本值有： 属性值 描述 right 不允许右侧有浮动元素 left 不允许左侧有浮动元素 both 同时清除两侧的浮动影响 把浮动的盒子圈到里面，让父元素闭合出口，让其不能影响外部元素。 额外标签在子元素最后增加一个盒子清除浮动。 1234567891011&lt;style&gt; .clear&#123; clear:both; &#125;&lt;/style&gt;&lt;div class="box"&gt; &lt;div class="son1"&gt;&lt;/div&gt; &lt;div class="son1"&gt;&lt;/div&gt; &lt;div class="clear"&gt;&lt;/div&gt; &lt;/div&gt;&lt;div class="ex"&gt;&lt;/div&gt; 父级元素增加overflow1234567891011&lt;style&gt; .box&#123; overflow:hidden; &#125;&lt;/style&gt;&lt;div class="box"&gt; &lt;div class="son1"&gt;&lt;/div&gt; &lt;div class="son1"&gt;&lt;/div&gt; &lt;div class="clear"&gt;&lt;/div&gt; &lt;/div&gt;&lt;div class="ex"&gt;&lt;/div&gt; 缺点：内容增多时容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。 使用after伪元素清除浮动1234567891011121314.clearfix:after&#123; content:".";/*防止就浏览器有空隙*/ display:block; height:0; clear:both; visibility:hidden;/*隐藏盒子*/&#125;.clearfix&#123; *zoom:1;/*兼容IE6、7*/&#125;&lt;div class="box1 clearfix"&gt; &lt;div class="son1"&gt;&lt;/div&gt; &lt;div class="son1"&gt;&lt;/div&gt; &lt;/div&gt; 与增加盒子法原理一样 使用双伪元素清除浮动1234567891011.clearfix:before,clearfix::after&#123; content: ""; display: table; &#125;.clearfix:after&#123; clear:both;&#125;.clearfix&#123; *zoom:1;/*兼容IE6、7*/&#125; flex布局来源：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html 一、Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为Flex布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。 123.box&#123; display: inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性align-items属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item &#123; order: &lt;integer&gt;;&#125; flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 grid布局来源：http://www.css88.com/archives/8506 Grid 布局是网站设计的基础，CSS Grid 是创建网格布局最强大和最简单的工具。 CSS Grid 今年也获得了主流浏览器（Safari，Chrome，Firefox，Edge）的原生支持，所以我相信所有的前端开发人员都必须在不久的将来学习这项技术。 在本文中，我将尽可能快速地介绍CSS网格的基本知识。我会把你不应该关心的一切都忽略掉了，只是为了让你了解最基础的知识。 你的第一个 Grid 布局CSS Grid 布局由两个核心组成部分是 wrapper（父元素）和 items（子元素）。 wrapper 是实际的 grid(网格)，items 是 grid(网格) 内的内容。 下面是一个 wrapper 元素，内部包含6个 items ： 123456789HTML 代码:&lt;div class="wrapper"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt;&lt;/div&gt; 要把 wrapper 元素变成一个 grid(网格)，只要简单地把其 display 属性设置为 grid 即可： 123CSS 代码:.wrapper &#123; display: grid;&#125; 但是，这还没有做任何事情，因为我们没有定义我们希望的 grid(网格) 是怎样的。它会简单地将6个 div 堆叠在一起。 我已经添加了一些样式，但是这与 CSS Grid 没有任何关系。 Columns(列) 和 rows(行)为了使其成为二维的网格容器，我们需要定义列和行。让我们创建3列和2行。我们将使用grid-template-row和grid-template-column属性。 1234CSS 代码:.wrapper &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 50px 50px;&#125; 正如你所看到的，我们为 grid-template-columns 写入了 3 个值，这样我们就会得到 3 列。 我们想要得到 2 行，因此我们为 grid-template-rows 指定了2个值。 这些值决定了我们希望我们的列有多宽（ 100px ），以及我们希望行数是多高（ 50px ）。 结果如下： 为了确保你能正确理解这些值与网格外观之间的关系，请看一下这个例子。 12345CSS 代码:.wrapper &#123; display: grid; grid-template-columns: 200px 50px 100px; grid-template-rows: 100px 30px;&#125; 请尝试理解上面的代码，思考一下以上代码会产生怎样的布局。 这是上面代码的布局的结果： 非常好理解，使用起来也非常简单是不是？下面我们来加大一点难度。 放置 items(子元素)接下来你需要学习的是如何在 grid(网格) 上放置 items(子元素) 。特别注意，这里才是体现 Grid 布局超能力的地方，因为它使得创建布局变得非常简单。 我们使用与之前相同的 HTML 标记，为了帮助我们更好的理解，我们在每个 items(子元素) 加上了单独的 class ： 123456789HTML 代码:&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;item1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item3&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;item4&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;item5&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;item6&quot;&gt;6&lt;/div&gt;&lt;/div&gt; 现在，我们来创建一个 3×3 的 grid(网格)： 1234CSS 代码:.wrapper &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;&#125; 将得到以下布局： 不知道你发现没有，我们只在页面上看到 3×2 的 grid(网格)，而我们定义的是 3×3 的 grid(网格)。这是因为我们只有 6 个 items(子元素) 来填满这个网格。如果我们再加3个 items(子元素)，那么最后一行也会被填满。 要定位和调整 items(子元素) 大小，我们将使用 grid-column 和 grid-row 属性来设置： 1234CSS 代码:.item1 &#123; grid-column-start: 1; grid-column-end: 4;&#125; 我们在这里要做的是，我们希望 item1 占据从第一条网格线开始，到第四条网格线结束。换句话说，它将独立占据整行。 以下是在屏幕上显示的内容： 如果你不明白我们设置的只有 3 列，为什么有4条网格线呢？看看下面这个图像，我画了黑色的列网格线： 请注意，我们现在正在使用网格中的所有行。当我们把第一个 items(子元素) 占据整个第一行时，它把剩下的 items(子元素) 都推到了下一行。 最后，给你一个更简单的缩写方法来编写上面的语法： 123CSS 代码:.item1 &#123; grid-column: 1 / 4;&#125; 为了确保你已经正确理解了这个概念，我们重新排列其他的 items(子元素) 。 12345678910CSS 代码:.item1 &#123; grid-column-start: 1; grid-column-end: 3;&#125;.item3 &#123; grid-row-start: 2; grid-row-end: 4;&#125;.item4 &#123; grid-column-start: 2; grid-column-end: 4;&#125; 你可以尝试在你的脑子里过一边上面代码的布局效果，应该不会很难。 以下是页面上的布局效果： Grid 布局就是这么简单，当然这里展示的是最简单的 Grid 布局概念，但是 Grid 布局系统中还有更多强大灵活的特性。作为本文续篇，请阅读 如何使用 CSS Grid 快速而又灵活的布局 让你体会 Grid 布局真正的强大和灵活。在此之前建议阅读请CSS Grid 布局完全指南(图解 Grid 详细教程)，首先了解一下 Grid 相关的术语和所有属性。 常用样式字体font-size 字体大小font-size属性用于设置字号，该属性可以使用相对长度单位，也可以使用绝对长度单位，常用px。 font-family 字体font-family用于设置字体，网页中常用的字体有宋体、微软雅黑、黑体等。 可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体,则会尝试下一个字体。 12中文字体需要加英文状态下的引号，英文字体一半不需要加引号，当设置英文字体时，英文字体必须位于中文字体名之前如果字体名中包含空格，#，$等符号，则该字体必须加英文状态下的单引号或双引号，列如：font-family:&quot;Time New Roman&quot; CSS unicode简单来说，用编码表示字体。 防止因文件编码不匹配产生乱码。 中文名 英文名 unicode unicode2 宋体 SimSun \5B8B\4F53 &amp;#x5B8B;&amp;#x4F53; 黑体 SimHei \9ED1\4F53 &amp;#x9ED1;&amp;#x4F53; 新宋体 NSimSun \65B0\5B8B\4F53 &amp;#x65B0;&amp;#x5B8B;&amp;#x4F53; 楷体 KaiTi \6977\4F53 &amp;#x6977;&amp;#x4F53; 微软正黑体 Microsoft JhengHei \5FAE\x8F6F\6B63\9ED1\4F53 &amp;#x5FAE;&amp;#x8F6F;&amp;#x6B63;&amp;#x9ED1;&amp;#x4F53; 微软雅黑 Microsoft YaHei \5FAE\8F6F\96C5\9ED1 &amp;#x5FAE;&amp;#x8F6F;&amp;#x96C5;&amp;#x9ED1; 参考资料：https://zhuyujia.github.io/css/css-font-unicode-table.html 字体强调font-weight 字体粗细字体加除了用b和strong标签外，可以用font-weight实现。 font-weight用于定义字体的粗细，其属性值可以为normal、bold、bloder、lighter、100~900（100的整数），其中400等价于 normal，700等价于bold font-style 字体风格字体倾斜除了用i和em外，可以用font-style实现。 其属性值有： normal 默认值，浏览器会显示标准的字体样式。 italic 斜体 oblique 倾斜 综合设定{font: font-style font-weihgt font-size/line-height font-family} 使用font属性时，必须按照以上顺序书写，不能更换顺序，各个属性之间一空格隔开。 其中不需要设置的属性可以忽略，但必须保留font-size和font-family属性 文字阴影（CSS3）text-shadow:水平位置 垂直位置 模糊距离 阴影颜色 1text-shadow: h-shadow v-shadow blur color; 注释：text-shadow 属性向文本添加一个或多个阴影。该属性是逗号分隔的阴影列表，每个阴影有两个或三个长度值和一个可选的颜色值进行规定。省略的长度是 0。 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊的距离。 color 可选。阴影的颜色。参阅 CSS 颜色值。 参考资料：http://www.w3school.com.cn/cssref/pr_text-shadow.asp 背景CSS可以添加背景颜色和背景图片，以及来进行图片设计。 background-color 背景颜色 background-image 背景图片 background-repeat 是否平铺 background-position 背景位置 background-attachment 背景是固定还是滚动 背景的合写 background: 颜色 图片地址 背景平铺 背景滚动 背景位置 背景位置默认值 ： 左上角 123background-position:length||lengthbackground-position:position||positiion 参数： length：百分数 数字值 position：top、center、bottom、left、right 方位名词没有顺序 设置或检索对象的背景图像位置。必须先指定background-image属性。默认值为（0% 0%） 如果只设定了一个值，该值将用于横坐标。纵坐标默认为50%。第二个值用于纵坐标。 注意： 1.postion 后面是x坐标和y坐标。可以使用方位名词或者精确单位。 2.如果精确单位和方位名词混合使用，必须是x坐标在前，y坐标在后面。 1background-postion:15px top; 背景附着1background-attachment:scroll||fixed; scroll: 背景图像是随内容滚动（默认值） fixed: 背景图像固定 背景透明使用rgba(0,0,0,透明度) 背景缩放background-size设置图片的尺寸 a、可以设置长度单位（px)或百分比（参照盒子的宽高） b、设置为cover时，会自动调整比例，保证图片填满背景区，如有溢出则会被隐藏。 c、设置为contain会自动调整比例，保证图片会完整的显示在背景区域（只要宽或高有一个达到了盒子的大小，则不会进行缩放,保证了图片完整） 多背景（CSS3）以逗号分隔可以设置多背景 一个元素可以设置多重背景图像 每组属性间用逗号隔开（定义属性的时候使用简写形式） 如果设置的多重背景图之间存在着交集（重叠关系），前面的背景图会覆盖在后面的背景图上 为了避免背景色将图像盖住，背景色通常为最后一组 12background:url(XXX.png) no-repeat scroll 10px 20px,url(YYY.png) no-repeat scroll left bottom; 显示与隐藏displaydisplay 设置检索对象如何显示。 dispay：none; 隐藏元素，隐藏之后，不在保留位置。 display：block；除了有转换为块级元素之外，还有显示元素的意思。 经常用于菜单。 visibiltyvisibilty:hidden;隐藏元素，并保留位置。 visibilty：visible; 显示元素。 overflow管理内容超出指定宽高时的做法。 值 说明 visible 默认值，超出显示 auto 自动，超出显示滚动条 scroll 一直显示滚动条（无论内容是否超出） hidden 超出部分隐藏 用户界面鼠标样式 cursor设置或检索在对象上移动鼠标指针采用何种系统预定义的光标形状。 cursor: default 小白(箭头）|pointer 小手|move 移动（十字标）|text 文本（光标） 轮廓 outline是绘制元素周围的一条线，位于边框的外围，可以起到突出元素的作用。 outline:outline-color||outline-style||outline-width (类似与border的设置) 我们平时都是去掉边框 写法为：outline:0; 1&lt;input type="text" style="outline:0"&gt; 防止拖拽文本域 resizeresize: none 防止用户随意拖拽文本域 1&lt;textarea style="resize:none;outline:0"&gt;&lt;/textarea&gt; 垂直对齐 vertical-alignvertical-align 不影响块级元素中的内容对齐，它只针对与行内元素或者行内块元素，特别是行内块元素，通常用来控制图片和表单文字的对齐。 vertical-align:baseline |top| middle| bottom 通常默认是基线对齐，比如： 12&lt;textarea name="" id="" cols="30" rows="10"&gt;&lt;/textarea&gt; &lt;p style="display:inline-block"&gt;文字文字文字文字&lt;/p&gt; 给文本域增加属性,使其与中线对齐 12&lt;textarea name="" id="" cols="30" rows="10" style="vertical-align:middle"&gt;&lt;/textarea&gt; &lt;p style="display:inline-block"&gt;文字文字文字文字&lt;/p&gt; 去除图片底侧空白间隙图片或者表单等行内块元素，它的底线会和父盒子的基线对齐，这样会造成图片底侧会有一个空白缝隙。 解决方案：1 将行内块元素转换块级元素， display:block; 2 给行内块元素添加 vertical-align:middle || top 等等， 让行内块元素不要和基线对齐。 ####溢出文字隐藏 word-break 自动换行主要处理英语 normal 浏览器的默认换行规则 break-all 允许在单词内换行（任何时候,可以拆开单词） keep-all 只能在半角空格或连字符处换行（无法拆开单词，除非出现连字符“-”） white-space设置或检索对象内文本的显示方式，通常我们使用与强制一行显示内容 normal: 默认处理方式 nowrap: 强制在同一行显示所有文本，直到文本结束或者遭遇br标签 text-overflow 文字溢出text-overflow: clip||ellipsis 设置是否使用一个省略标记(…)表示对象文本的溢出 clip 不显示省略标记，而是简单的裁切 ellipsis 溢出时用省略号标记 注意使用条件 一定要首先强制一行内显示，再次和overflow属性搭配使用 123white-space: nowrap;/*首先添加这句话，强制不换行*/overflow: hidden;/*必须有这句话，溢出部分隐藏*/text-overflow: ellipsis; 字体图标图片是有诸多优点的，但是图片不能进行良好的“缩放”，因为图片的放大和缩小会失真，而且还增加了总文件的大小。但是字体图标可以改善这些缺点。 优点1234可以做出和图片一样的事情，改变透明度，旋转度，等但是本质是文字，可以改变颜色，产生阴影，透明效果等....体积小，但是所携带的信息没有消减几乎支持所有的浏览器 使用上传生成字体包当我们有.svg文件时，我们需要转换成我们页面能使用的字体文件，而且需要生成的是兼容性的适合各个浏览器的。 推荐网站：http://icomoon.io 阿里字库 http://www.icofont.cn/ icomoon的使用1 将font文件夹放到目录文件夹上 2 在样式中声明字体 在下载的文件夹中style文件中复制如下的代码放进css中 注意路径问题 比如： 12345678910@font-face &#123; font-family: 'icomoon'; src: url('fonts/icomoon.eot?1adt26'); src: url('fonts/icomoon.eot?1adt26#iefix') format('embedded-opentype'), url('fonts/icomoon.ttf?1adt26') format('truetype'), url('fonts/icomoon.woff?1adt26') format('woff'), url('fonts/icomoon.svg?1adt26#icomoon') format('svg'); font-weight: normal; font-style: normal;&#125; 3 增加span标签，并添加样式font-family: &quot;icomoon&quot; （要与上面声明的字体样式名字一样） 4 将demo中样式后面的小方格复制到span标签中 或增加样式span::before{content:&quot;\e906&quot;} (字体图标下面的代码) 追加新图标将压缩包中的selection.json从新上传，然后选中自己想要的新图标，从新下载压缩包，替换原来的文件即可。 动画过渡过渡三要素: 1 必须要有属性发生变化 2 必须告诉系统哪个属性发生了变化 transition-property 3 必须告诉系统过渡效果持续的时长 transition-duration 例如： 1234567891011121314.gd&#123; width: 300px; height: 200px; background-color: red; /* 告诉系统哪个属性需要执行过渡效果 */ transition-property: width,background-color; /* 告诉系统过渡效果所用的时间 */ transition-duration: 5s, 6s;&#125;/* 伪类选择器也可以用在不是a标签上，只是表示监听鼠标指向元素的事件 */.gd:hover&#123; width: 500px; background-color: blue;&#125; 其它的过渡属性： transition-delay 规定了过渡效果何时开始 transition-timing-function 规定了过渡的运动曲线 属性的连写： transition: property duration timing-function delay; transition: 过渡属性 过渡时长 运动时间函数 延迟 如果想给多个属性增加过渡效果用逗号隔开 连写的时候可以省略后两个参数 如果多个属性运动的速度/延迟的时间/持续的时间都一样，可以简写为： transition:all 0s; 如何编写过渡： 1 不要管过渡，先编写基本界面 2 修改我们认为需要修改的属性 3回过头去给被修改属性的那个元素添加过渡效果 2D转换通过 CSS3 转换，我们能够对元素进行移动、缩放、转动、拉长或拉伸。 基本属性 transformrotate() 方法通过 rotate() 方法，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。 1234.d2 ul li:nth-child(2)&#123; /* 其中deg是单位，代表多少度 */ transform: rotate(45deg);&#125; translate() 方法通过 translate() 方法，元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数： 12345.d2 ul li:nth-child(3)&#123; /* 第一个参数:水平方向 第二个参数：垂直方向 */ transform: translate(100px, 50px);&#125; scale() 方法通过 scale() 方法，元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数： 123456789.d2 ul li:nth-child(4)&#123; /* 第一个参数:水平方向 第二个参数：垂直方向 如果取值为1， 代表不变 取值大于1 放大 取值小于1 缩小 如果水平和垂直的参数都一样，可以简写为一个参数*/ transform: scale(1.5,1.5);&#125; 如果需要进行多个转换，要用空格隔开 2D转化模块会修改元素的坐标系，所以旋转之后的平移就不是水平平移了 形变中心点默认情况下所有的元素都是以自己的中心点作为参考来旋转的，我们可以通过形变中心点属性来修改它的参考点 transform-origin：0px 0px; 第一个参数:水平方向 第二个参数:垂直方向 注意点: 取值有三种形式：具体像素 百分比 特殊关键字(left center top等) 旋转轴向默认情况下所有元素都是围绕Z轴进行旋转 Z轴的正方向为垂直屏幕向外 想围绕哪个轴旋转, 那么只需要在rotate后面加上哪个轴即可 比如rotateX(45deg) rotateY(-45deg) rotate Z(180deg) 透视：perspective: 500px; 呈现一种近大远小的效果,一般和旋转搭配使用 注意点:一定要注意, 透视属性必须添加到需要呈现近大远小效果的元素的父元素上面 注意过渡尽量:hover的元素和改变的元素是同一个，通过A:hover去控制B的也可以用CSS做，具体做法是：A是父级，B是子集，那么A:hover &gt;B{}就可以了（认为A:hover时找到B） AB同级时，A:hover ~B(A在HTML中在B的上面，认为A:hover时找到B) CSS 相邻兄弟选择器： + （A:hover +B) 选择紧接在另一个元素后的元素，而且二者有相同的父元素 ~ 在使用 ~ 连接两个元素时,它会匹配第二个元素,条件是它必须跟(不一定是紧跟)在第一个元素之后,且他们都有一个共同的父元素. 有一个过渡显示二级菜单的例子是通过:hover一级菜单的li去显示二级菜单的li的例子 代码：https://paste.ubuntu.com/p/84j55Xws62/ 3D转换关键： transform-style： preserve-3d //子元素将保留其 3D 位置 默认值为flat 即为2D转换 实例：画一个正方体 先画六个面，通过旋转和位移将面围成正方体，需要注意的是，当面进行旋转操作的时候，对于这个元素的坐标系会跟着一起旋转 具体可以看这个代码就明白了， https://paste.ubuntu.com/p/V6YwZp6HJV/ 动画过渡与动画的不同点： 过渡必须人为的触发才会执行 动画不需要人为的触发就可以执行动画 相同点： 过渡和动画都需要满足三要素 动画的用法：1 先告诉系统需要执行哪个动画 animation-name: lxx(随便给动画起个名称)； 2 告诉系统我们要创建一个名称为lxx的动画 12345678@keyframes lxx&#123; from&#123; 默认态&#125; to&#123; 结束状态&#125;&#125; 动画的过程也可以用%表示 1234567891011121314@keyframe lxx&#123; 0%&#123; &#125; 33%&#123; &#125; 66%&#123; &#125; 100%&#123; &#125;&#125; 3 告诉系统动画持续的时长 animation-duration:3s; 其它属性animation-iteration-count: 3; 动画需要执行几次 animation-direction：alternate;动画应该轮流反向播放 默认值：normal 动画不执行往返 animation-play-state: runing/paused 规定动画是否暂停（与hover联合使用） animation-fill-mode 值 描述 none 不改变默认行为。(恢复没有动画的状态) forwards 当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。 backwards 在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。（让动画在等待状态时显示第一帧的样子） both 向前和向后填充模式都被应用。（forward和backwards一起） 连写animation: name duration timing-function delay iteration-count direction;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
